<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NEMoSys: NucMesh Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="IRTriangles_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NEMoSys
   &#160;<span id="projectnumber">0.63.0</span>
   </div>
   <div id="projectbrief">A modular, extensible resource with robust automated mesh generation, mesh quality analysis, adaptive mesh refinement, and data transfer between arbitrary meshes.</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('nucmesh_UG.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">NucMesh Tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#nucmesh_intro">Introduction to NucMesh</a><ul><li class="level2"><a href="#nucmesh_input">Making a NucMesh Input File</a></li>
</ul>
</li>
<li class="level1"><a href="#tuts">Tutorials</a><ul><li class="level2"><a href="#tut1">Tutorial 1: Circles, Polygons, and Simple Arrays</a><ul><li class="level3"><a href="#tut1_1">Circles</a></li>
<li class="level3"><a href="#tut1_2">Materials</a></li>
<li class="level3"><a href="#tut1_3">Off-center Objects</a></li>
<li class="level3"><a href="#tut1_4">Circles And Polys</a></li>
<li class="level3"><a href="#tut1_5">Rotation</a></li>
<li class="level3"><a href="#tut1_6">Polar Arrays</a></li>
<li class="level3"><a href="#tut1_7">Hexagonal Arrays</a></li>
</ul>
</li>
<li class="level2"><a href="#tut2">Tutorial 2: Rectangular Arrays, Saved Objects, Arrays of Arrays, and Extrusion</a><ul><li class="level3"><a href="#tut2_1">Rectangular Arrays</a></li>
<li class="level3"><a href="#tut2_2">Saved Objects</a></li>
<li class="level3"><a href="#tut2_3">Using Polar Arrays to Create Arcs</a></li>
<li class="level3"><a href="#tut2_4">Overwriting Parameters for Saved Objects</a></li>
<li class="level3"><a href="#tut2_5">Arrays of Arrays</a></li>
<li class="level3"><a href="#tut2_6">Extrusion</a></li>
</ul>
</li>
<li class="level2"><a href="#tut3">Tutorial 3: Meshes</a><ul><li class="level3"><a href="#tut3_1">Quadrilateral Meshes</a></li>
<li class="level3"><a href="#tut3_2">Structured Meshes</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="nucmesh_intro"></a>
Introduction to NucMesh</h1>
<p><em>NucMesh</em> is specifically designed to generate meshes for nuclear reactors. It features the capability to quickly create arrays (rectangular, polar, and hexagonal) made up of custom objects, such as circles, polygons, or other arrays.</p>
<p><em>NucMesh</em> allows the user to efficiently specify, save, create arrays of, and mesh elementary shapes such as circles and regular polygons. It is designed to create 2D meshes, but also has the capability to extrude meshes into 3D space.</p>
<p><a class="el" href="nucmesh_ref.html">The reference page</a> contains information on the parameters used in <em>NucMesh</em> input files.</p>
<h2><a class="anchor" id="nucmesh_input"></a>
Making a NucMesh Input File</h2>
<p>All <em>NucMesh</em> JSON input files start in the same way: </p><pre class="fragment">{
  "Program Type": "NucMesh Generation",
  "Mesh File Options": {
    "Output Mesh File": "mesh_name.vtu"
  },
</pre><p>The <code>"Program Type"</code> is set to <code>"NucMesh Generation"</code> and the mesh file to be created is named. Note that the output mesh file might be VTK or EXODUS II format.</p>
<p>Next, <em>NucMesh</em>-specific options are provided in the <code>"NucMesh Options"</code> section. <code>"Saved Objects"</code> may be any kind of shape or array of shapes. </p><pre class="fragment">  "NucMesh Options": {
    "Saved Objects": [
      {
        "Name": 
        "Type":
        ...
      }
    ],
    "Shapes": [
      {
        "Type":
        ...
      }
    ],
    "Extrude": []
  }
</pre><h1><a class="anchor" id="tuts"></a>
Tutorials</h1>
<p>These tutorials are designed to gently lead a new user through the current capabilities of <em>NucMesh</em>.</p>
<h2><a class="anchor" id="tut1"></a>
Tutorial 1: Circles, Polygons, and Simple Arrays</h2>
<div class="image">
<img src="arrays3_trace.png" alt="arrays3_trace.png" width="400"/>
<div class="caption">
This tutorial will cover constructing the shape above, both with and without using arrays.</div></div>
<div class="image">
<img src="arrays5_trace.png" alt="arrays5_trace.png" width="400"/>
<div class="caption">
To include hexagonal arrays, the above shape will also be constructed.</div></div>
<h3><a class="anchor" id="tut1_1"></a>
Circles</h3>
<p>To create a circle, at least one radius must be specified. This is done within the <code>"Rings"</code> block, which makes it easy to add as many concentric circles as needed, each with their own mesh type, material, or sideset. For example, this input produces a circular triangular mesh with a radius of 5 units. </p><pre class="fragment">{
  "Program Type": "NucMesh Generation",
  "Mesh File Options": {"Output Mesh File": "simple_circles.vtu"},
  "NucMesh Options": {
    "Shapes": [
      {"Type": "Circles", "Rings": [{"Radius": 5, "Mesh": {"Type": "T"}}]}
    ]
  }
}
</pre><div class="image">
<img src="circles1.png" alt="circles1.png" width="400"/>
<div class="caption">
A circle of radius 5, meshed with triangular elements.</div></div>
<p>To add another circle, another radius and mesh type are added within the <code>"Rings"</code> array: </p><pre class="fragment">{
  "Program Type": "NucMesh Generation",
  "Mesh File Options": {"Output Mesh File": "circles.vtu"},
  "NucMesh Options": {
    "Shapes": [
      {"Type": "Circles", "Rings": [{"Radius": 4, "Mesh": {"Type": "T"}},
                                    {"Radius": 5, "Mesh": {"Type": "T"}}]}
    ]
  }
}
</pre><p>Note that the new circle, which has a radius of 4, is added <b>above</b> the initial circle. <em>NucMesh</em> expects radii to be listed in increasing order&ndash;doing otherwise will result in an error.</p>
<div class="image">
<img src="circles2.png" alt="circles2.png"/>
<div class="caption">
Two concentric circles of radii 4 and 5, meshed with triangular elements. Without different </div></div>
<p> material types, discerning the border of the inner circle is a little difficult." width=400</p>
<h3><a class="anchor" id="tut1_2"></a>
Materials</h3>
<p>Looking closely at the mesh shown above, you can see that there is indeed a ring and two distinct circles. However, without different material types, <em>Paraview</em> does not perceive them as different entities. To make it a little clearer, we can assign different materials to the two rings: </p><pre class="fragment">{
  "Program Type": "NucMesh Generation",
  "Mesh File Options": {"Output Mesh File": "circles.vtu"},
  "NucMesh Options": {
    "Shapes": [
      {"Type": "Circles", "Rings": [{"Radius": 4, "Mesh": {"Type": "T"}, "Material": "A"},
                                    {"Radius": 5, "Mesh": {"Type": "T"}, "Material": "B"}]}
    ]
  }
}
</pre><div class="image">
<img src="circles3.png" alt="circles3.png" width="400"/>
<div class="caption">
Changing material types helps Paraview display the two circles more clearly</div></div>
<h3><a class="anchor" id="tut1_3"></a>
Off-center Objects</h3>
<p>Let's add a few more circles&ndash;instead of concentric, let's try adding three small circles within the smaller circle. To specify a center that isn't just the default of [0, 0, 0], we add the <code>"Center"</code> keyword to place each small circle 2 units away from the center: </p><pre class="fragment">{
  "Program Type": "NucMesh Generation",
  "Mesh File Options": {"Output Mesh File": "circles.vtu"},
  "NucMesh Options": {
    "Shapes": [
      {"Type": "Circles", "Rings": [{"Radius": 4, "Mesh": {"Type": "T"}, "Material": "A"},
                                    {"Radius": 5, "Mesh": {"Type": "T"}, "Material": "B"}]},
      {"Type": "Circles", "Center": [0, 2, 0], "Rings":[ {"Radius": 1, "Mesh": {"Type": "T"}, "Material": "C"}]},
      {"Type": "Circles", "Center": [1.732050808, -1, 0], "Rings":[ {"Radius": 1, "Mesh": {"Type": "T"}, "Material": "C"}]},
      {"Type": "Circles", "Center": [-1.732050808, -1, 0], "Rings":[ {"Radius": 1, "Mesh": {"Type": "T"}, "Material": "C"}]}
    ]
  }
}
</pre><div class="image">
<img src="circles4.png" alt="circles4.png" width="400"/>
<div class="caption">
Three evenly distributed circles of radii 1, each added individually.</div></div>
<p>Since each of the smallest circles has a different center, they must be added individually. A later tutorial will introduce polar arrays, which allow the user to very quickly create the same configuration, without requiring the user to manually calculate each circle's center and add them manually.</p>
<h3><a class="anchor" id="tut1_4"></a>
Circles And Polys</h3>
<p>To create polygon shapes, <code>"Circles And Polys"</code> is used as the shape's <code>"Type"</code>. This requires a few more parameters than for circle specification: the type of polygon is determined with the <code>"Number of Sides"</code> keyword, and within the <code>"Rings"</code> section, a <code>"Shape Type"</code> (which may be <code>"Circle"</code> or <code>"Poly"</code>) must be specified. Note that the number of sides is specified outside of the <code>"Rings"</code> section, because only one type of polygon can be used within a <code>"Circles And Polys"</code> object. To give the size of the polygon, the <code>"Radius"</code> keyword is used, and refers to the radius of the circumscribing circle.</p>
<p>As an example, let's add a polygon inside each of the three smallest circles: </p><pre class="fragment">{
  "Program Type": "NucMesh Generation",
  "Mesh File Options": {"Output Mesh File": "circles.vtu"},
  "NucMesh Options": {
    "Shapes": [
      {
        "Type": "Circles", "Rings": [{"Radius": 4, "Mesh": {"Type": "T"}, "Material": "A"},
                                    {"Radius": 5, "Mesh": {"Type": "T"}, "Material": "B"}]
      },
      {
        "Type": "Circles And Polys", 
        "Center": [0, 2, 0], 
        "Number of Sides": 5,
        "Rings":[{"Shape Type": "Poly", "Radius": 0.6, "Mesh": {"Type": "T"}, "Material": "D"},
                 {"Shape Type": "Circle", "Radius": 1, "Mesh": {"Type": "T"}, "Material": "C"}]
      },
      {
        "Type": "Circles And Polys",
        "Center": [1.732050808, -1, 0],
        "Number of Sides": 5,
        "Rings":[{"Shape Type": "Poly", "Radius": 0.6, "Mesh": {"Type": "T"}, "Material": "D"},
                 {"Shape Type": "Circle", "Radius": 1, "Mesh": {"Type": "T"}, "Material": "C"}]
      },
      {
        "Type": "Circles And Polys", 
        "Center": [-1.732050808, -1, 0], 
        "Number of Sides": 5,
        "Rings":[{"Shape Type": "Poly", "Radius": 0.6, "Mesh": {"Type": "T"}, "Material": "D"},
                 {"Shape Type": "Circle", "Radius": 1, "Mesh": {"Type": "T"}, "Material": "C"}]
      }
    ]
  }
}
</pre><p>Note that again, the new shapes are added above the exiting once since they have a smaller radius.</p>
<div class="image">
<img src="circlesAndPolys1.png" alt="circlesAndPolys1.png" width="400"/>
<div class="caption">
Adding polygons within the smaller circles.</div></div>
<h3><a class="anchor" id="tut1_5"></a>
Rotation</h3>
<p>Each pentagon is oriented with the flat side at the bottom. Until now, all the shapes have been circles and therefore their orientation hasn't been a concern. Now, to ensure radial symmetry, the second and third polygons will be rotated: </p><pre class="fragment">{
  "Program Type": "NucMesh Generation",
  "Mesh File Options": {"Output Mesh File": "circles.vtu"},
  "NucMesh Options": {
    "Shapes": [
      {"Type": "Circles", "Rings": [{"Radius": 4, "Mesh": {"Type": "T"}, "Material": "A"},
                                    {"Radius": 5, "Mesh": {"Type": "T"}, "Material": "B"}]},
      {"Type": "Circles And Polys", 
       "Center": [0, 2, 0], 
       "Number of Sides": 5,
       "Rings":[{"Shape Type": "Poly", "Radius": 0.6, "Mesh": {"Type": "T"}, "Material": "D"},
                {"Shape Type": "Circle", "Radius": 1, "Mesh": {"Type": "T"}, "Material": "C"}]},
      {"Type": "Circles And Polys",
       "Center": [1.732050808, -1, 0],
       "Number of Sides": 5,
       "Rings":[{"Shape Type": "Poly", "Radius": 0.6, "Mesh": {"Type": "T"}, "Rotation": -60, "Material": "D"},
                {"Shape Type": "Circle", "Radius": 1, "Mesh": {"Type": "T"}, "Material": "C"}]},
      {"Type": "Circles And Polys", 
       "Center": [-1.732050808, -1, 0], 
       "Number of Sides": 5,
       "Rings":[{"Shape Type": "Poly", "Radius": 0.6, "Mesh": {"Type": "T"}, "Rotation": 60, "Material": "D"},
                {"Shape Type": "Circle", "Radius": 1, "Mesh": {"Type": "T"}, "Material": "C"}]}
    ]
  }
}
</pre><div class="image">
<img src="circlesAndPolys2.png" alt="circlesAndPolys2.png" width="400"/>
<div class="caption">
Rotating the polygons within the smaller circles to maintain radial symmetry.</div></div>
<p>For a few simple shapes, calculating positions and rotation angles is not too difficult. However, if design changes required that there be seven circles, each with a seven-sided polygon inside, recalculating and updating all the required values and copy-pasting new shapes could quickly become onerous.</p>
<h3><a class="anchor" id="tut1_6"></a>
Polar Arrays</h3>
<p>Arrays, which can be rectangular, polar, or hexagonal, technically fall under the category of <code>"Shapes"</code> in <em>NucMesh</em>. Each type of array has its own parameter requirements, but all three require a list of shapes that are present in the array and a specification for the pattern.</p>
<p>We can replace the three <code>"Circles And Polys"</code> shapes with a single polar array. Instead of calculating each small circle's center individually, we can omit the <code>"Center"</code> keyword entirely, and let the default center of [0, 0, 0] be used. Setting the <code>"Radius"</code> to 2 will place each array object 2 units away from the center, with no trigonometry required. Since we want the small circles evenly spaced around the entire circle, we specify a <code>"Start Angle"</code> of 0 degrees and an <code>"End Angle"</code> of 360 degrees. To get the pentagons to rotate with the array and maintain radial symmetry, we set <code>"Rotate with Array"</code> to <code>true</code>.</p>
<p>The <code>"Pattern"</code> for a polar array is set with a 1D array. In this case, we use <code>[0, 0, 0]</code> to indicate that we want three of the first (zero indexed) shape listed to be evenly spaced between the <code>"Start Angle"</code> and the <code>"End Angle"</code>. Since only one shape is being used in the polar array, only one needs to be listed. </p><pre class="fragment">{
  "Program Type": "NucMesh Generation",
  "Mesh File Options": {"Output Mesh File": "circles.vtu"},
  "NucMesh Options": {
    "Shapes": [
      {"Type": "Circles", "Rings": [{"Radius": 4, "Mesh": {"Type": "T"}, "Material": "A"},
                                    {"Radius": 5, "Mesh": {"Type": "T"}, "Material": "B"}]},
      {"Type": "Polar Array",
       "Radius": 2,
       "Pattern": [0, 0, 0],
       "Start Angle": 0,
       "End Angle": 360,
       "Rotate with Array": true,
       "Shapes": [
         {"Type": "Circles And Polys", 
          "Center": [0, 0, 0], 
          "Number of Sides": 5,
          "Rings":[{"Shape Type": "Poly", "Radius": 0.6, "Mesh": {"Type": "T"}, "Material": "D"},
                   {"Shape Type": "Circle", "Radius": 1, "Mesh": {"Type": "T"}, "Material": "C"}]}            
        ]
      }
    ]
  }
}
</pre><div class="image">
<img src="arrays1.png" alt="arrays1.png" width="400"/>
<div class="caption">
An initial attempt to replace manually entered shapes with an array.</div></div>
<p>The mesh pictured above is not quite the same as the one created manually. <em>NucMesh</em> measures angles from the positive <em>x</em> axis, so setting the <code>"Start Angle"</code> to 0 means that the first <code>"Circles And Polys"</code> object is placed there, instead of at 90 degrees. To fix this, we can change the <code>"Start Angle"</code> and the <code>"End Angle"</code> to 90 degrees and 450 degrees (note that entering 90 degrees here is also totally acceptable): </p><pre class="fragment">{
  "Program Type": "NucMesh Generation",
  "Mesh File Options": {"Output Mesh File": "circles.vtu"},
  "NucMesh Options": {
    "Shapes": [
      {"Type": "Circles", "Rings": [{"Radius": 4, "Mesh": {"Type": "T"}, "Material": "A"},
                                    {"Radius": 5, "Mesh": {"Type": "T"}, "Material": "B"}]},
      {"Type": "Polar Array",
       "Radius": 2,
       "Pattern": [0, 0, 0],
       "Start Angle": 90,
       "End Angle": 450,
       "Rotate with Array": true,
       "Shapes": [
         {"Type": "Circles And Polys", 
          "Center": [0, 0, 0], 
          "Number of Sides": 5,
          "Rings":[{"Shape Type": "Poly", "Radius": 0.6, "Mesh": {"Type": "T"}, "Material": "D"},
                   {"Shape Type": "Circle", "Radius": 1, "Mesh": {"Type": "T"}, "Material": "C"}]}            
        ]
      }
    ]
  }
}
</pre><div class="image">
<img src="arrays2.png" alt="arrays2.png"/>
<div class="caption">
The second attempt to replace manually entered shapes with an array, which fixes the position </div></div>
<p> of the smaller circles but not the orientation of the polygons within them." width=400</p>
<p>The smallest circles are now correctly positioned, but the pentagons within them are not aligned as expected. To get the correct position, the polygon must be oriented so that it is correct <em>relative to the original 0 degree</em>&ndash;in this case, we can simply negate the rotation imposed by changing the starting angle by simply setting the <code>"Poly"</code> object's rotation to -90 degrees.</p>
<pre class="fragment">{
  "Program Type": "NucMesh Generation",
  "Mesh File Options": {"Output Mesh File": "circles.vtu"},
  "NucMesh Options": {
    "Shapes": [
      {"Type": "Circles", "Rings": [{"Radius": 4, "Mesh": {"Type": "T"}, "Material": "A"},
                                    {"Radius": 5, "Mesh": {"Type": "T"}, "Material": "B"}]},
      {"Type": "Polar Array",
       "Radius": 2,
       "Pattern": [0, 0, 0],
       "Start Angle": 90,
       "End Angle": 90,
       "Rotate with Array": true,
       "Shapes": [
         {"Type": "Circles And Polys", 
          "Center": [0, 0, 0], 
          "Number of Sides": 5,
          "Rings":[{"Shape Type": "Poly", "Radius": 0.6, "Mesh": {"Type": "T"}, "Rotation": -90, "Material": "D"},
                   {"Shape Type": "Circle", "Radius": 1, "Mesh": {"Type": "T"}, "Material": "C"}]}            
        ]
      }
    ]
  }
}
</pre><div class="image">
<img src="arrays3.png" alt="arrays3.png" width="400"/>
<div class="caption">
To get the pentagon's original orientation, negate the array's rotation (indicated with the Start Angle) in the specification of the Poly object.</div></div>
<p>Once the <code>"Circles And Polys"</code> object is positioned correctly, the <code>"Rotate with Array"</code> setting ensures that each repeated object is also oriented correctly.</p>
<p>Now that we have a convenient array of objects, let's change some parameters: change the number of small circles to six and the polygon inside to a square. To fit the additional circles, we'll also expand the polar array radius to 2.5: </p><pre class="fragment">{
  "Program Type": "NucMesh Generation",
  "Mesh File Options": {"Output Mesh File": "circles.vtu"},
  "NucMesh Options": {
    "Shapes": [
      {"Type": "Circles", "Rings": [{"Radius": 4, "Mesh": {"Type": "T"}, "Material": "A"},
                                    {"Radius": 5, "Mesh": {"Type": "T"}, "Material": "B"}]},
      {"Type": "Polar Array",
       "Radius": 2.5,
       "Pattern": [0, 0, 0, 0, 0, 0],
       "Start Angle": 90,
       "End Angle": 450,
       "Rotate with Array": true,
       "Shapes": [
         {"Type": "Circles And Polys", 
          "Center": [0, 0, 0], 
          "Number of Sides": 4,
          "Rings":[{"Shape Type": "Poly", "Radius": 0.6, "Mesh": {"Type": "T"}, "Rotation": -90, "Material": "D"},
                   {"Shape Type": "Circle", "Radius": 1, "Mesh": {"Type": "T"}, "Material": "C"}]}            
        ]
      }
    ]
  }
}
</pre><div class="image">
<img src="arrays4.png" alt="arrays4.png" width="400"/>
<div class="caption">
Changing the size of the array or number of sides requires very little alteration of the input file.</div></div>
<h3><a class="anchor" id="tut1_7"></a>
Hexagonal Arrays</h3>
<p>We can fill the middle of the larger circles with a hexagonal array of hexagons, which we will rotate by 30 degrees: </p><pre class="fragment">{
  "Program Type": "NucMesh Generation",
  "Mesh File Options": {"Output Mesh File": "circles.vtu"},
  "NucMesh Options": {
    "Shapes": [
      {"Type": "Circles", "Rings": [{"Radius": 4, "Mesh": {"Type": "T"}, "Material": "A"},
                                    {"Radius": 5, "Mesh": {"Type": "T"}, "Material": "B"}]},
      {"Type": "Polar Array",
       "Radius": 2.5,
       "Pattern": [0, 0, 0, 0, 0, 0],
       "Start Angle": 90,
       "End Angle": 450,
       "Rotate with Array": true,
       "Shapes": [
         {"Type": "Circles And Polys", 
          "Center": [0, 0, 0], 
          "Number of Sides": 4,
          "Rings":[{"Shape Type": "Poly", "Radius": 0.6, "Mesh": {"Type": "T"}, "Rotation": -90, "Material": "D"},
                   {"Shape Type": "Circle", "Radius": 1, "Mesh": {"Type": "T"}, "Material": "C"}]}            
          ]
        },
        {"Type": "Hexagonal Array",
         "Grid Distance": 1,
         "Pattern": [[0,0],[0,0,0],[0,0]],
         "Shapes": [
            {"Type": "Circles And Polys",
             "Center": [0, 0, 0],
             "Number of Sides": 6,
             "Rings": [{"Shape Type": "Poly", "Radius": 0.3, "Mesh": {"Type": "T"}, "Rotation": 30, "Material": "B"}]
            }
          ]
        }
    ]
  }
}
</pre><div class="image">
<img src="arrays5.png" alt="arrays5.png" width="400"/>
<div class="caption">
A hexagonal array can be added as a 2D array with some specified distance between object centers.</div></div>
<p>Hexagonal arrays are declared with a 2D array and a grid distance, which specifies the spacing between the centers of the objects in the array. Although the user is able to define their own pattern so that the shape IDs can be placed appropriately, the numbers of rows and columns are restricted to regular hexagonal shapes: </p><pre class="fragment">[[0, 0], 
 [0, 0, 0], 
 [0, 0]]

[[0, 0, 0],
 [0, 0, 0, 0],
 [0, 0, 0, 0, 0]
 [0, 0, 0, 0],
 [0, 0, 0]]

[[0, 0, 0, 0],
 [0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0],
 [0, 0, 0, 0]]
</pre><p>etc., where <code>0</code> can be replaced by the index of the desired shape within the array's <code>"Shapes"</code> list.</p>
<h2><a class="anchor" id="tut2"></a>
Tutorial 2: Rectangular Arrays, Saved Objects, Arrays of Arrays, and Extrusion</h2>
<p>The two arrays used thus far included only a single shape. To demonstrate how different shapes can be incorporated into arrays, let's introduce rectangular arrays, the third and final array type.</p>
<div class="image">
<img src="squoval_trace.png" alt="squoval_trace.png" width="400"/>
<div class="caption">
This tutorial will cover constructing a set of circle objects in the shape of a square with rounded corners in Promesh.</div></div>
<h3><a class="anchor" id="tut2_1"></a>
Rectangular Arrays</h3>
<p>Let's start with an array of circles forming the outline of a square: </p><pre class="fragment">{
  "Program Type": "NucMesh Generation",
  "Mesh File Options": {"Output Mesh File": "squoval.vtu"},
  "NucMesh Options": {
    "Shapes": [
      {
        "Type": "Rectangular Array",
        "Grid Distance": [1, 1],
        "Pattern": [[1, 1, 1, 1, 1, 1, 1, 1, 1], 
                    [1, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1]],

          "Shapes": [
          null,
          {
            "Type": "Circles",
            "Rings": [{"Radius": 0.225, "Mesh": {"Type":"T"}, "Material": "A"},
                      {"Radius": 0.45, "Mesh": {"Type":"T"}, "Material": "B"}]
          }
        ]
      }
    ]
  }
}
</pre><p>Rectangular arrays only require specification of a grid distance (the distance between the centers of adjacent points). Unlike for hexagonal arrays, it is possible to specify a different distance in the <em>x</em>- and <em>y</em>-directions, so a JSON array is used instead of a single value. Rectangular arrays use a 2D array of arrays to specify the pattern.</p>
<p>Note that in this pattern, we use two different shapes. Because <code>null</code> is the first in the array's <code>Shapes</code> list, its index is 0. Every 0 in the pattern thus corresponds to <code>null</code>, meaning that no shape will be placed there. The second object in the array's <code>Shapes</code> list is a circle with two rings, and its index is 1.</p>
<div class="image">
<img src="squoval0.png" alt="squoval0.png" width="400"/>
<div class="caption">
Rectangular arrays can be used to make grids of evenly spaced objects.</div></div>
<p>Say we want the corners of the square to be more rounded. We'll additionally add a third shape (identical to the second shape, except with different materials) and change the straight edges in the pattern to 2: </p><pre class="fragment">{
  "Program Type": "NucMesh Generation",
  "Mesh File Options": {"Output Mesh File": "squoval.vtu"},
  "NucMesh Options": {
    "Shapes": [
      {
        "Type": "Rectangular Array",
        "Grid Distance": [1, 1],
        "Pattern": [[0, 0, 1, 2, 2, 2, 1, 0, 0], 
                    [0, 1, 0, 0, 0, 0, 0, 1, 0],
                    [1, 0, 0, 0, 0, 0, 0, 0, 1],
                    [2, 0, 0, 0, 0, 0, 0, 0, 2],
                    [2, 0, 0, 0, 0, 0, 0, 0, 2],
                    [2, 0, 0, 0, 0, 0, 0, 0, 2],
                    [1, 0, 0, 0, 0, 0, 0, 0, 1],
                    [0, 1, 0, 0, 0, 0, 0, 1, 0],
                    [0, 0, 1, 2, 2, 2, 1, 0, 0]],

          "Shapes": [
          null,
          {
            "Type": "Circles",
            "Rings": [{"Radius": 0.225, "Mesh": {"Type":"T"}, "Material": "A"},
                      {"Radius": 0.45, "Mesh": {"Type":"T"}, "Material": "B"}]
          },
          {
            "Type": "Circles",
            "Rings": [{"Radius": 0.225, "Mesh": {"Type":"T"}, "Material": "C"},
                      {"Radius": 0.45, "Mesh": {"Type":"T"}, "Material": "D"}]
          }
        ]
      }
    ]
  }
}
</pre><div class="image">
<img src="squoval1.png" alt="squoval1.png" width="400"/>
<div class="caption">
Rectangular grid spacing doesn't allow for the same spacing between straight and diagonal edges.</div></div>
<p>With a smaller rectangular array, making smooth curves is impossible. Additionally, the grid doesn't allow the space between objects to be the same along diagonal and cardinal sides. We could create a much larger rectangular array, which would make differences in spacing less obvious and allow us to form a better curve, but entering in hundreds of integers to define the pattern would get tedious very quickly.</p>
<h3><a class="anchor" id="tut2_2"></a>
Saved Objects</h3>
<p>Instead, let's use polar arrays to specify the corners. To make this easier, we'll introduce <code>Saved Objects</code>, which allow us to define a shape or array, name it, and use it later. </p><pre class="fragment">{
  "Program Type": "NucMesh Generation",
  "Mesh File Options": {"Output Mesh File": "squoval.vtu"},
  "NucMesh Options": {
    "Saved Objects":[
      {
        "Name": "circleAB",
        "Type": "Circles",
        "Rings": [{"Radius": 0.225, "Mesh": {"Type":"T"}, "Material": "A"},
                  {"Radius": 0.45, "Mesh": {"Type":"T"}, "Material": "B"}]
      },
      {
        "Name": "circleCD",
        "Type": "Circles",
        "Rings": [{"Radius": 0.225, "Mesh": {"Type":"T"}, "Material": "C"},
                  {"Radius": 0.45, "Mesh": {"Type":"T"}, "Material": "D"}]
      }
    ],
    "Shapes": [
      {
        "Type": "Rectangular Array",
        "Grid Distance": [1, 1],
        "Pattern": [[0, 0, 0, 1, 1, 1, 0, 0, 0], 
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [1, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 1],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 1, 1, 1, 0, 0, 0]],

          "Shapes": [
          null,
          {"Saved Object": "circleCD"}
        ]
      },
      {
        "Type": "Polar Array",
        "Start Angle": -15,
        "End Angle": 345,
        "Radius": 4,
        "Pattern": [0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1],
        "Shapes": [
          null,
          {"Saved Object": "circleAB"}
        ]
      }
    ]
  }
}
</pre><p>Note that the rectangular array's pattern has been changed&ndash;the corners have been set to <code>null</code> and the index of the edges has been set to 1. This still corresponds to the same shape, but now it is second in the list of shapes instead of third.</p>
<div class="image">
<img src="squoval2.png" alt="squoval2.png" width="400"/>
<div class="caption">
Arrays can be overlapped, so that the polar array covers the corners and the rectangular array covers the straight edges. Objects specified by null will not be in conflict with other objects.</div></div>
<p>The spacing in the above image is much improved, but the corners are so rounded that the entire shape looks like a circle. Ideally, the angle between the adjacent objects in the straight edges and corners should be zero, but this will require four polar arrays, similar to what is shown below:</p>
<div class="image">
<img src="goal_squoval3.png" alt="goal_squoval3.png" width="400"/>
<div class="caption">
To get a nicely rounded edge that is aligned with the straight edges, four polar arrays must be used, each with a different center.</div></div>
<h3><a class="anchor" id="tut2_3"></a>
Using Polar Arrays to Create Arcs</h3>
<p>Corners will be represented with polar arrays. Polar arrays are designed to work nicely for full circles, which makes the end angle behave a little unexpectedly for incomplete arcs. For example, if we want a polar array that starts at 0 degrees and ends at 360 degrees, with a pattern of [0, 1, 2, 3], we would expect to see four objects at the cardinal directions&ndash;and of course, that is exactly what we get. However, note that this means that object 0 is at 0 degrees, object 1 is at 90 degrees, object 2 is at 180 degrees, and object 3 is at 270 degrees; there is no object at 360 degrees, because the array is designed to overlap with the original object at 0 degrees. Creating incomplete arcs therefore requires a little extra care.</p>
<p>Objects within an array will be \(\frac{end\ angle - start\ angle}{number\ of\ shapes}\) degrees apart. To get three evenly spaced objects in a quarter circle, we need the angle between them to be 45 degrees. Therefore, the end angle that should be used is \((45)(3) + start\ angle\).</p>
<h3><a class="anchor" id="tut2_4"></a>
Overwriting Parameters for Saved Objects</h3>
<p>To avoid having to manually create four arrays, we can use a single saved array (called <code>"corner"</code> in the input file shown below). This represents the top-right corner. Because our start angle is 0, we set the end angle to 135, as was explained above. After the rectangular array is specified, the saved <code>"corner"</code> object is used four times. The first instance is left unmodified, but for the next three, the <code>Center</code>, <code>Start Angle</code>, and <code>End Angle</code> are overwritten with custom values so that each corner is properly specified. </p><pre class="fragment">{
  "Program Type": "NucMesh Generation",
  "Mesh File Options": {"Output Mesh File": "squoval.vtu"},
  "NucMesh Options": {
    "Saved Objects":[
      {
        "Name": "circleAB",
        "Type": "Circles",
        "Rings": [{"Radius": 0.225, "Mesh": {"Type":"T"}, "Material": "A"},
                  {"Radius": 0.45, "Mesh": {"Type":"T"}, "Material": "B"}]
      },
      {
        "Name": "circleCD",
        "Type": "Circles",
        "Rings": [{"Radius": 0.225, "Mesh": {"Type":"T"}, "Material": "C"},
                  {"Radius": 0.45, "Mesh": {"Type":"T"}, "Material": "D"}]
      },
      {
        "Name": "corner",
        "Type": "Polar Array",
        "Center": [2, 2, 0],
        "Start Angle": 0,
        "End Angle": 135,
        "Radius": 2,
        "Pattern": [0, 0, 0],
        "Shapes": [{"Saved Object": "circleAB"}]
      }
    ],
    "Shapes": [
      {
        "Type": "Rectangular Array",
        "Grid Distance": [1, 1],
        "Pattern": [[0, 0, 0, 1, 1, 1, 0, 0, 0], 
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [1, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 1],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 1, 1, 1, 0, 0, 0]],

          "Shapes": [
          null,
          {"Saved Object": "circleCD"}
        ]
      },
      {"Saved Object": "corner"},
      {"Saved Object": "corner", "Center": [-2, 2, 0], "Start Angle": 90, "End Angle": 225},
      {"Saved Object": "corner", "Center": [-2, -2, 0], "Start Angle": 180, "End Angle": 315},
      {"Saved Object": "corner", "Center": [2, -2, 0], "Start Angle": 270, "End Angle": 405}
    ]
  }
}
</pre><div class="image">
<img src="squoval3.png" alt="squoval3.png" width="400"/>
<div class="caption">
Some values in saved objects can be overwritten when they are used, allowing the user to avoid creating many objects with only minor changes.</div></div>
<p>Note that with three circles in the corners, the spacing looks a little too wide. Fortunately, changing to four circles requires only adding an extra <code>0</code> to the <code>Pattern</code> and recalculating the <code>End Angle</code>s for each of the uses of the <code>"corner"</code> object (+120 from the <code>Start Angle</code>s, which will remain the same). </p><pre class="fragment">      ...
      {
        "Name": "corner",
        "Type": "Polar Array",
        "Center": [2, 2, 0],
        "Start Angle": 0,
        "End Angle": 120,
        "Radius": 2,
        "Pattern": [0, 0, 0, 0],
        "Shapes": [{"Saved Object": "circleAB"}]
      }
      ...
      {"Saved Object": "corner"},
      {"Saved Object": "corner", "Center": [-2, 2, 0], "Start Angle": 90, "End Angle": 210},
      {"Saved Object": "corner", "Center": [-2, -2, 0], "Start Angle": 180, "End Angle": 300},
      {"Saved Object": "corner", "Center": [2, -2, 0], "Start Angle": 270, "End Angle": 390}
</pre><div class="image">
<img src="squoval4.png" alt="squoval4.png" width="400"/>
<div class="caption">
The Pattern and End Angles must be updated for every instance of the corner object.</div></div>
<h3><a class="anchor" id="tut2_5"></a>
Arrays of Arrays</h3>
<p>Instead of using a single large and ungainly rectangular array to create the edges, we can create a polar array consisting of four small rectangular arrays. Because <em>NucMesh</em> orients objects relative to the positive <em>x</em>-direction, the array should be entered as a three row, single column 2D array. When placed at 0 degrees, this will form the right vertical edge. </p><pre class="fragment">      ...
      {
        "Name": "edge",
        "Type": "Rectangular Array",
        "Grid Distance": [1, 1],
        "Pattern": [[0], [0], [0]],
        "Shapes": [{"Saved Object": "circleAB"}]
      }
      ...
</pre><p>The polar array that places the edges is a simple four element array that forms a complete circle. <code>Rotate with Array</code> is set to <code>true</code>, so the vertical array rotates to place the edges correctly. </p><pre class="fragment">{
  "Program Type": "NucMesh Generation",
  "Mesh File Options": {"Output Mesh File": "squoval.vtu"},
  "NucMesh Options": {
    "Saved Objects":[
      {
        "Name": "circleAB",
        "Type": "Circles",
        "Rings": [{"Radius": 0.225, "Mesh": {"Type":"T"}, "Material": "A"},
                  {"Radius": 0.45, "Mesh": {"Type":"T"}, "Material": "B"}]
      },
      {
        "Name": "circleCD",
        "Type": "Circles",
        "Rings": [{"Radius": 0.225, "Mesh": {"Type":"T"}, "Material": "C"},
                  {"Radius": 0.45, "Mesh": {"Type":"T"}, "Material": "D"}]
      },
      {
        "Name": "corner",
        "Type": "Polar Array",
        "Center": [2, 2, 0],
        "Start Angle": 0,
        "End Angle": 120,
        "Radius": 2,
        "Pattern": [0, 0, 0, 0],
        "Shapes": [{"Saved Object": "circleAB"}]
      },
      {
        "Name": "edge",
        "Type": "Rectangular Array",
        "Grid Distance": [1, 1],
        "Pattern": [[0], [0], [0]],
        "Shapes": [{"Saved Object": "circleCD"}]
      }
    ],
    "Shapes": [
      {
        "Type": "Polar Array",
        "Start Angle": 0,
        "End Angle": 360,
        "Radius": 4,
        "Rotate with Array": true,
        "Pattern": [0, 0, 0, 0],
        "Shapes": [{"Saved Object": "edge"}]
      },
      {"Saved Object": "corner"},
      {"Saved Object": "corner", "Center": [-2, 2, 0], "Start Angle": 90, "End Angle": 210},
      {"Saved Object": "corner", "Center": [-2, -2, 0], "Start Angle": 180, "End Angle": 300},
      {"Saved Object": "corner", "Center": [2, -2, 0], "Start Angle": 270, "End Angle": 390}
    ]
  }
}
</pre><div class="image">
<img src="squoval4a.png" alt="squoval4a.png" width="400"/>
<div class="caption">
Replacing the single rectangular array with a polar array of smaller rectangular arrays cleans up the input file and makes it easier to edit the pattern without making errors.</div></div>
<h3><a class="anchor" id="tut2_6"></a>
Extrusion</h3>
<p>This 2D mesh can be extruded to create a 3D mesh with the <code>"Extrude"</code> keyword. We can provide an array of values to specify where cell divisions will be made, like so: </p><pre class="fragment">{
  "Program Type": "NucMesh Generation",
  "Mesh File Options": {"Output Mesh File": "squoval.vtu"},
  "NucMesh Options": {
    "Saved Objects":[
      {
        ...
      }
    ],
    "Shapes": [
      {
        ...
      }
    ],
    "Extrude": [0.5, 0.5, 0.1]
  }
}
</pre><div class="image">
<img src="extrude.png" alt="extrude.png" width="600"/>
<div class="caption">
The user can specify the heights of the extruded cells directly through the values provided in the Extrude array.</div></div>
<p>Note that the total height of the extruded mesh will be the sum of the values in the Extrude array.</p>
<h2><a class="anchor" id="tut3"></a>
Tutorial 3: Meshes</h2>
<p><em>NucMesh</em> offers three meshing options for 2D shapes: triangular, quadrilateral, and structured. To demonstrate how these different mesh types can be used to improve the overall mesh quality, the following input file will be used: </p><pre class="fragment">{
  "Program Type": "NucMesh Generation",
  "Mesh File Options": {"Output Mesh File": "mesh_types.vtu"},
  "NucMesh Options": {
    "Saved Objects": [
      {
        "Name": "scc",
        "Type": "Circles And Polys",
        "Number of Sides": 4,
        "Rings": [ {"Shape Type": "Circle", "Radius": 5,"Material": "A", "Mesh": {"Type": "T"}},
                   {"Shape Type": "Circle", "Radius": 10, "Material": "B", "Mesh": {"Type": "T"}},
                   {"Shape Type": "Poly", "Radius": 21.2132034356, "Material": "C", "Mesh": {"Type": "T"}}
                 ]
      },
      {
        "Name": "scs",
        "Type": "Circles And Polys",
        "Number of Sides": 4,
        "Rings": [ {"Shape Type": "Poly", "Radius": 7.07106781187,"Material": "D", "Mesh": {"Type": "T"}},
                   {"Shape Type": "Circle", "Radius": 10, "Material": "E", "Mesh": {"Type": "T"}},
                   {"Shape Type": "Poly", "Radius": 21.2132034356, "Material": "F", "Mesh": {"Type": "T"}}
                 ]
      },
      {
        "Name": "small_square",
        "Type": "Circles And Polys",
        "Number of Sides": 4,
        "Rings": [ {"Shape Type": "Poly", "Radius": 7.07106781187, "Material": "G", "Mesh": {"Type": "T"}} ]
      }
    ],
  "Shapes" : [
    {
      "Type": "Rectangular Array",
      "Grid Distance": [10, 25],
      "Pattern": [[1, 1, 1, 1, 0, 3, 0, 1, 1, 1, 1, 1, 0, 2, 0, 1],
                  [0, 2, 0, 1, 1, 1, 1, 1, 0, 3, 0, 1, 1, 1, 1, 1],
                  [1, 1, 1, 1, 0, 3, 0, 1, 1, 1, 1, 1, 0, 2, 0, 1]],
      "Shapes": [
        null,
        {"Saved Object": "small_square"},
        {"Saved Object": "scs"},
        {"Saved Object": "scc"}
        ] 
      }
    ]
  }
}
</pre><div class="image">
<img src="mesh1.png" alt="mesh1.png" width="800"/>
<div class="caption">
A rectangular array of carefully placed Circles And Polys objects and null objects.</div></div>
<p>Note that each specified mesh type is <code>"T"</code> (triangular). This results in the following mesh:</p>
<div class="image">
<img src="mesh2.png" alt="mesh2.png" width="800"/>
<div class="caption">
Using only triangular meshes results in poor quality elements, particularly in the corners of the largest squares.</div></div>
<h3><a class="anchor" id="tut3_1"></a>
Quadrilateral Meshes</h3>
<p>Let's change the smaller square's meshes to type <code>"Q"</code> (quadrilateral).</p>
<div class="image">
<img src="mesh3.png" alt="mesh3.png" width="800"/>
<div class="caption">
Quadrilateral elements are well suited to square objects.</div></div>
<h3><a class="anchor" id="tut3_2"></a>
Structured Meshes</h3>
<p>Structured meshes require an additional parameter; a non-zero integer pair [r, c] must be specified to define the number of elements in the radial and circumferential directions of the shape. Note that the c parameter will represent <em>half</em> the circumference&ndash;for 20 elements around the shape, c should be set to 10.</p>
<p>Let's change the middle circle of the object with two concentric circles (named <code>"scc"</code>) to a structured mesh with 2 elements in the radial direction and 12 elements in the circumferential directions: </p><pre class="fragment">  ...
   {
    "Name": "scc",
    "Type": "Circles And Polys",
    "Number of Sides": 4,
    "Rings": [ {"Shape Type": "Circle", "Radius": 5,"Material": "A", "Mesh": {"Type": "T"}},
               {"Shape Type": "Circle", "Radius": 10, "Material": "B", "Mesh": {"Type": "S", "Number of Elems": [2,6]}},
               {"Shape Type": "Poly", "Radius": 21.2132034356, "Material": "C", "Mesh": {"Type": "T"}}
             ]
  }
  ...
</pre><div class="image">
<img src="mesh4.png" alt="mesh4.png" width="800"/>
<div class="caption">
Specifying a structured mesh for the middle ring of one of the objects improves the quality of that mesh, but also of the adjacent meshes.</div></div>
<p>The only rule regarding structured meshes is that they should not be used in the center circle of an object. Let's change the middle ring on the other Circles And Polys object (named <code>"scs"</code>) to a structured mesh as well, this time with 10 circumferential elements: </p><pre class="fragment">  ...
  {
    "Name": "scs",
    "Type": "Circles And Polys",
    "Number of Sides": 4,
    "Rings": [ {"Shape Type": "Poly", "Radius": 7.07106781187,"Material": "D", "Mesh": {"Type": "Q"}},
               {"Shape Type": "Circle", "Radius": 10, "Material": "E", "Mesh": {"Type": "S", "Number of Elems": [2,5]}},
               {"Shape Type": "Poly", "Radius": 21.2132034356, "Material": "F", "Mesh": {"Type": "T"}}
             ]
  }
  ...
</pre><div class="image">
<img src="mesh5.png" alt="mesh5.png" width="800"/>
<div class="caption">
Careful mesh type specification can improve mesh quality. Note that the edges of the scs object are chunkier and less smooth; the best trade off between element size and geometric precision is one the user has to determine for themselves.</div></div>
<p>With the structure provided by the structured mesh, a quadrilateral mesh is a good fit for the innermost circle of the <code>"scc"</code> object: </p><pre class="fragment">  ...
   {
    "Name": "scc",
    "Type": "Circles And Polys",
    "Number of Sides": 4,
    "Rings": [ {"Shape Type": "Circle", "Radius": 5,"Material": "A", "Mesh": {"Type": "Q"}},
               {"Shape Type": "Circle", "Radius": 10, "Material": "B", "Mesh": {"Type": "S", "Number of Elems": [2,6]}},
               {"Shape Type": "Poly", "Radius": 21.2132034356, "Material": "C", "Mesh": {"Type": "T"}}
             ]
  }
  ...
</pre><div class="image">
<img src="mesh6.png" alt="mesh6.png" width="800"/>
<div class="caption">
Specifying the number of elements in a structured mesh allows you to indirectly prescribe the number of elements in adjacent meshes, even if they are triangular or quadrilateral meshes.</div></div>
 </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Jan 26 2022 16:40:03 for NEMoSys by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
