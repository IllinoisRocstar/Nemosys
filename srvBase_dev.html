<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NEMoSys: srvBase</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="IRTriangles_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NEMoSys
   &#160;<span id="projectnumber">0.62.1</span>
   </div>
   <div id="projectbrief">A modular, extensible resource with robust automated mesh generation, mesh quality analysis, adaptive mesh refinement, and data transfer between arbitrary meshes.</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('srvBase_dev.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">srvBase </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><code>srvBase</code> is an abstract base class that implements complex operations on <code>geoMeshBase</code> objects. Note that <code>srvBase</code> inherits from <code>vtkAlgorithm</code>, so the memory management tips in geomeshbase also apply to <code>srvBase</code> objects. Some additional resources for understanding <code>vtkAlgorithm</code>:</p>
<ul>
<li>This <a href="https://vtk.org/Wiki/VTK/Tutorials/New_Pipeline">wiki page</a> provides an overview of <code>vtkAlgorithm</code>.</li>
<li>The <a href="https://www.kitware.com/products/books/VTKUsersGuide.pdf">VTK Users' Guide</a> chapters 15 and 17 offer a more detailed guide to implementing custom <code>vtkAlgorithm</code>s. (Caution: this book was written for VTK 5.4!)</li>
<li>The new <a href="https://kitware.github.io/vtk-examples/site/">VTK examples site</a> includes an updated overview (see VTKBook &gt; Chapter 4, in particular sections 4.2-4.4) and full \ examples (see Cxx &gt; Developers).</li>
<li>This <a href="https://blog.kitware.com/a-vtk-pipeline-primer-part-1/">series of blog posts</a> provides examples (mostly Python) of a custom <code>vtkAlgorithm</code> as well as some explanation of the design of <code>vtkAlgorithm</code>.</li>
</ul>
<h1><a class="anchor" id="execution"></a>
Execution</h1>
<p>Note that <code>srvBase</code> objects can be pipelined, that is, services can take the other <code>srvBase</code> objects as inputs. More precisely, output ports and input ports of different <code>srvBase</code> objects can be connected, as in:</p>
<div class="fragment"><div class="line">vtkNew&lt;fooGeoMesh&gt; <a class="code" href="RocPartCommGenDriver_8C.html#ae1987ccab405402474115b5c67acd514">mesh</a>;</div><div class="line">vtkNew&lt;myFooSrv&gt; srv1;</div><div class="line">vtkNew&lt;myFooSrv&gt; srv2;</div><div class="line">srv1-&gt;SetInputDataObject(mesh);</div><div class="line">srv2-&gt;SetInputConnection(srv1-&gt;GetOutputPort());</div><div class="line">srv2-&gt;Update();</div></div><!-- fragment --><p> Execution of the entire pipeline only happens when <code>Update</code> is called on <code>srv2</code>. If the service has not been modified since the last time it was updated, then it does nothing. Otherwise, the service and any inputs to the service that need to be updated (and their inputs and so on) do four things, in the following order:</p>
<ul>
<li><code>RequestDataObject</code> is called on each service in the forward direction, meaning <code>RequestDataObject</code> is called on a service's inputs before it is called on the service (<code>srv1</code> before <code>srv2</code>). This method creates empty objects to store the results of a service.</li>
<li><code>RequestInformation</code> is called on each service in the forward direction. This method passes metadata about the result of a service to subsequent services that might need it.</li>
<li><code>RequestUpdateExtent</code> is called on each service in the backward direction, meaning <code>RequestDataObject</code> is called on a service before it is called on the service's inputs (<code>srv2</code> before <code>srv1</code>). This method tells its input services what portion of the data it needs, in case the input service can save resources by only partially executing.</li>
<li><code>RequestData</code> is called on each service in the forward direction. <code>RequestData</code> runs the actual algorithm that a service represents by writing data into the object previously created by <code>RequestDataObject</code>.</li>
</ul>
<p>Note that the input and output information and data are all passed between services via <code>vtkInformation</code>, which holds key-value pairs, where the keys are instances of <code>vtkInformationKey</code>.</p>
<h1><a class="anchor" id="implementation"></a>
Implementing a Driver</h1>
<p>Suppose we want to implement some service <code>myFooSrv</code> that takes <code>fooGeoMesh</code> objects, runs some algorithm, and results in another <code>fooGeoMesh</code> object, with some option <code>Bar</code> that controls the algorithm. Here's what the header of <code>myFooSrv</code> might look like:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>myFooSrv : <span class="keyword">public</span> srvBase {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        vtkTypeMacro(myFooSrv, srvBase)</div><div class="line">        <span class="keyword">static</span> myFooSrv *<a class="code" href="namespaceNEM_1_1MSH.html#a6dec3dd9e4a5682417877ae516d7fce8">New</a>();</div><div class="line">        vtkSetMacro(Bar, <span class="keywordtype">int</span>);</div><div class="line">        vtkGetMacro(Bar, <span class="keywordtype">int</span>);</div><div class="line">    <span class="keyword">protected</span>:</div><div class="line">        myFooSrv();</div><div class="line">        <span class="keywordtype">int</span> RequestData(vtkInformation *request,</div><div class="line">            vtkInformationVector **inputVector,</div><div class="line">            vtkInformationVector *outputVector) <span class="keyword">override</span>;</div><div class="line">        <span class="keywordtype">int</span> FillInputPortInformation(<span class="keywordtype">int</span> port, vtkInformation *info) <span class="keyword">override</span>;</div><div class="line">        <span class="keywordtype">int</span> FillOutputPortInformation(<span class="keywordtype">int</span> port, vtkInformation *info) <span class="keyword">override</span>;</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        <span class="keywordtype">int</span> Bar{};</div><div class="line">}</div></div><!-- fragment --><p> Note the use of Pascal/upper camel case for the private data member <code>Bar</code> so that the setters and getters created by <code>vtkSetMacro</code> and <code>vtkGetMacro</code> are consistently capitalized.</p>
<h2><a class="anchor" id="vtktypemacro"></a>
vtkTypeMacro</h2>
<p>The <code>vtkTypeMacro</code> declares and defines methods that <em>VTK</em> uses to do run-time type checking and cloning. The macro generates both declarations and definitions.</p>
<h2><a class="anchor" id="new"></a>
New</h2>
<p>The static <code>New</code> method is used to create new instances, and is also how <code>vtkSmartPointer&lt;&gt;</code> and <code>vtkNew&lt;&gt;</code> create new instances. Sample implementation: </p><div class="fragment"><div class="line"><a class="code" href="namespaceNEM_1_1MSH.html#a057a98ce70ab73b5b44eb2c5ab37670d">vtkStandardNewMacro</a>(myFooSrv)</div></div><!-- fragment --><h2><a class="anchor" id="setandget"></a>
vtkSetMacro and vtkGetMacro</h2>
<p>Prefer using these macros (and similar ones in <code>vtkSetGet.h</code>) for implementing setters and getters of options of services. In particular, if writing custom setter functions (or any functions that alter the execution of the algorithm), remember to call <code>Modified</code> before returning.</p>
<h2><a class="anchor" id="portinfo"></a>
FillInputPortInformation and FillOutputPortInformation</h2>
<p>The inputs and outputs of a service (generally <code>geoMeshBase</code> objects; simpler inputs can be treated as options) are defined in terms of ports. Input ports should at least set the <code>INPUT_REQUIRED_DATA_TYPE()</code> key so that the input data type can be checked. Other keys that might be of interest include <code>vtkAlgorithm::INPUT_IS_OPTIONAL()</code> and <code>vtkAlgorithm::INPUT_IS_REPEATABLE()</code>. Output ports should at least set the <code>DATA_TYPE_NAME()</code> key so that the output data type can be checked and so that the appropriate data type is used in <code>RequestDataObject</code>. Note that the value for <code>DATA_TYPE_NAME()</code> should be the same for all instances of the service. If you find yourself tempted to set this value depending on options or the input, you most likely need to override <code>RequestDataObject</code> and implement the logic there. The return values indicate success (<code>1</code>) or failure (<code>0</code>). Sample implementation: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> myFooSrv::FillInputPortInformation(<span class="keywordtype">int</span> port, vtkInformation *info) {</div><div class="line">    <span class="keywordflow">if</span> (port == 0) {</div><div class="line">        info-&gt;Set(vtkAlgorithm::INPUT_REQUIRED_DATA_TYPE(), <span class="stringliteral">&quot;fooGeoMesh&quot;</span>);</div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> myFooSrv::FillOutputPortInformation(<span class="keywordtype">int</span> port, vtkInformation *info) {</div><div class="line">    <span class="keywordflow">if</span> (port == 0) {</div><div class="line">        info-&gt;Set(vtkDataObject::DATA_TYPE_NAME(), <span class="stringliteral">&quot;fooGeoMesh&quot;</span>);</div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="constructor"></a>
Constructor</h2>
<p>The constructor should set the number of input and output ports for the service. Sample implementation: </p><div class="fragment"><div class="line">myFooSrv::myFooSrv() {</div><div class="line">    this-&gt;SetNumberOfInputPorts(1);</div><div class="line">    this-&gt;SetNumberOfOutputPorts(1);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="requestdata"></a>
RequestData</h2>
<p>This method contains the main logic of the service. Note that the input and output objects are contained in the <code>inputVector</code> and <code>outputVector</code> arguments. Be sure to return <code>0</code> on failure or <code>1</code> on success. Sample implementation: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> myFooSrv::RequestData(vtkInformation *request,</div><div class="line">    vtkInformationVector **inputVector,</div><div class="line">    vtkInformationVector *outputVector) {</div><div class="line">    <span class="comment">// first index corresponds to input port</span></div><div class="line">    <span class="comment">// second index used if input is repeatable</span></div><div class="line">    <span class="keyword">auto</span> inInfo = inputVector[0]-&gt;GetInformationObject(0);</div><div class="line">    <span class="comment">// index corresponds to output port</span></div><div class="line">    <span class="keyword">auto</span> outInfo = outputVector-&gt;GetInformationObject(0);</div><div class="line">    <span class="keyword">auto</span> input = MSH::fooGeoMesh::SafeDownCast(</div><div class="line">        inInfo-&gt;Get(vtkDataObject::DATA_OBJECT()));</div><div class="line">    <span class="keyword">auto</span> output = MSH::fooGeoMesh::SafeDownCast(</div><div class="line">        outInfo-&gt;Get(vtkDataObject::DATA_OBJECT()));</div><div class="line">    Foo outputFoo = input-&gt;getFooMesh(); <span class="comment">// copy</span></div><div class="line">    outputFoo.runAlgorithm(this-&gt;Bar);</div><div class="line">    output-&gt;setFooMesh(std::move(outputFoo));</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="requestdataobject"></a>
RequestDataObject</h2>
<p>This method creates the output data object for the service before anything is executed. <code>srvBase</code> contains a default implementation for this method, which uses the <code>vtkDataObject::DATA_TYPE_NAME()</code> key. If the value given by this key refers to a concrete type, then a new instance of the concrete type will be created. If the value associated with <code>DATA_TYPE_NAME()</code> is <code>"geoMeshBase"</code>, then the output object will be created by calling <code>NewInstance</code> on the input object of the input port (specifically, the first object on the input port with the same index). If some custom logic is needed for creating the output object, override this method. Ths overridden method should create the output data object and set it as the value for the <code>vtkDataObject::DATA_OBJECT()</code> key for each <code>vtkInformation</code> in the <code>outputVector</code>. Be sure to return <code>0</code> on failure or <code>1</code> on success Note that each <code>FillOutputPortInformation</code> should set the <code>DATA_TYPE_NAME()</code> key even in <code>RequestDataObject</code> is overridden.</p>
<h2><a class="anchor" id="requestinfo"></a>
RequestInformation</h2>
<p>This method provides metadata about the output that subsequent services might need. The <code>srvBase</code> implementation does nothing; override it if needed.</p>
<h2><a class="anchor" id="requestupdateextent"></a>
RequestUpdateExtent</h2>
<p>This method notifies input services about what extent of the input it needs. The <code>srvBase</code> implementation sets <code>vtkStreamingDemandDrivenPipeline::EXACT_EXTENT()</code> to 1 for all inputs. Override it if needed, particularly for streaming algorithms. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Jan 26 2022 16:22:44 for NEMoSys by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
