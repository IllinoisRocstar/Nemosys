<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NEMoSys: drivers_dev.md Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="IRTriangles_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NEMoSys
   &#160;<span id="projectnumber">0.62.1</span>
   </div>
   <div id="projectbrief">A modular, extensible resource with robust automated mesh generation, mesh quality analysis, adaptive mesh refinement, and data transfer between arbitrary meshes.</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('drivers__dev_8md.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">drivers_dev.md</div>  </div>
</div><!--header-->
<div class="contents">
<a href="drivers__dev_8md.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;@page drivers_dev</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;The driver classes (which inherit from `NEM::MSH::NemDriver`) are the highest level of abstraction. Each driver represents some workflow that can be executed using the virtual `NemDriver::execute()` method. Users specify parameters via getters and setters. Note that the drivers also can be run from the command line using the `nemosysRun` executable and a &lt;em&gt;JSON&lt;/em&gt; file, or in Python via `pyNemosys`.</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;@section implementation Implementing a Driver</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;Suppose we want to implement some driver `FooDriver`. Here&#39;s what the header of `FooDriver` might look like:</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;~~~{.c}</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    class NEMOSYS_EXPORT FooDriver : public NemDriver {</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;        public:</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;            using Files = DriverInOutFiles;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;            struct NEMOSYS_EXPORT Opts {</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;                public:</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;                    explicit Opts(std::vector&lt;int&gt; member1);</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;                    std::vector&lt;int&gt; member1;</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;                    double member2{0.9};</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;                    jsoncons::optional&lt;int&gt; member3{};</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;                    JSONCONS_TYPE_TRAITS_FRIEND</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;                private:</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;                    Opts() = default;</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;            }</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;            FooDriver(Files files, Opts opts);</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;            const Files &amp;getFiles() const;</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;            void setFiles(Files files);</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;            const Opts &amp;getOpts() const;</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;            void setOpts(Opts opts);</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;            void execute() const override;</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;            JSONCONS_TYPE_TRAITS_FRIEND</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;        private:</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;            FooDriver();</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;            static constexpr const char *programType = &quot;Foo&quot;;</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;            jsoncons::string_view getProgramType() const override;</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;            </div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;            Files files_;</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;            Opts opts_;</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    }</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;~~~</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;Ideally, drivers only do two things: accept parameters for some workflow, and execute it. To that end, note that `execute` is `const`, because there should be no reason to alter the state of the driver when running. The following sections describe some of the members in more detail.</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;@subsection privateconstructors Private Constructors</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;The way that &lt;em&gt;NEMoSys&lt;/em&gt; implements &lt;em&gt;JSON&lt;/em&gt; deserialization requires that classes have default constructors. However, if the class would not otherwise have a default constructor (because some members need to be set by the user in order for the object to be meaningful), make the default constructor private and use the `JSONCONS_TYPE_TRAITS_FRIEND` macro so that the &lt;em&gt;JSON&lt;/em&gt; deserialization can use the default constructor. If the default constructor requires an explicit definition, set the required values to any value--the &lt;em&gt;JSON&lt;/em&gt; interface will ensure at run-time that the user provides a value. See @ref deserialization for details on &lt;em&gt;JSON&lt;/em&gt; deserialization.</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;@subsection filesopts Files, files_, Opts, and opts_</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;Drivers act on files and a set of parameters. To group these, most drivers have nested classes (with standardized names `Files` and `Opts`) and one member of each of these types (note the trailing underscore for private members, following the Google C++ style guide). The `struct` keyword rather than `class` is used to suggest that the purpose of these nested classes is just to hold data. Note that many drivers have just a single output mesh file, or have an input and an output. Use an alias declaration, if necessary (with the `using` keyword) to enforce consistent naming.</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;Drivers have both required and optional parameters. To enforce this, make sure any publicly available constructors have some way to set each required parameter, so that all `Opts` structs are always in a valid state. Member variables with default values should be initialized where they are declared, rather than through the constructor, both so that it is obvious from the header alone what the default value is, and so that the default constructor can be defined using `= default`. Note that in some cases, options can be turned on or off, but turning them on requires additional parameters. To represent these types of optional values, use the `jsoncons::optional&lt;T&gt;` template, which represents an object of type `T` or the absence of any object at all. For more info about `jsoncons::optional`, note that is has the same interface as `std::optional`.</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;@subsection deserialization JSON Deserialization for Drivers</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;Deserialization of a type from &lt;em&gt;JSON&lt;/em&gt; relies on macros that generate code defining a specialization of the `jsoncons::json_type_traits&lt;Json, T&gt;` template. Please read [this page](https://github.com/danielaparker/jsoncons/blob/v0.159.0/doc/ref/json_type_traits.md) from the &lt;em&gt;jsoncons&lt;/em&gt; documentation. Note that in addition to the macros documented [here]({https://github.com/danielaparker/jsoncons/blob/v0.159.0/doc/ref/json_type_traits/convenience-macros.md), &lt;em&gt;NEMoSys&lt;/em&gt; provides additional macros to support virtual inheritance in `NemJsonMacros.H`. Specializations for many STL types (including more containers, `std::pair`, `std::optional`, `std::shared_ptr`, `std::unique_ptr`, and `jsoncons::optional`) are [already provided](https://github.com/danielaparker/jsoncons/blob/v0.159.0/doc/ref/json_type_traits/built-in-specializations.md) based on specializations of `jsoncons::json_type_traits&lt;Json,T&gt;` for the templated type. The following is an example of using these macros for `FooDriver`:</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;~~~{.c}</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;    #ifndef NEMOSYS_FOOJSON_H_</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    #define NEMOSYS_FOOJSON_H_</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;    #include &quot;Drivers/FooDriver.H&quot;</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    #include &quot;Drivers/NemJsonMacros.H&quot;</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    NEM_JSON_N_GETTER_SETTER_NAME_TRAITS_FINAL(</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;        NEM::DRV::FooDriver, NEM::DRV::NemDriver, 2,</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;        (getFiles, setFiles, NEM::DRV::JSON::meshFiles),</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;        (getOpts, setOpts, &quot;Foo Driver Options&quot;),</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;        (getProgramType, , NEM::DRV::JSON::programType, NEM_JSON_RDONLY_OVERRIDE,</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;            [](const jsoncons::string_view &amp;x) {</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;                return x == NEM::DRV::FooDriver::programType;</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;            }))</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;    JSONCONS_N_MEMBER_NAME_TRAITS(NEM::DRV::FooDriver::Opts, 1,</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;        (member1, &quot;First Option&quot;),</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;        (member2, &quot;Second Option&quot;),</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;        (member3, &quot;Third Option&quot;))</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;    #endif // NEMOSYS_FOOJSON_H_</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;~~~</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;This file might be named `FooJson.H` and live under `include/Drivers` (possibly within a subdirectory, mimicking where `FooJson.C` is located). Note that `FooJson.H` should not be installed! Finally, make sure to add `FooDriver` to `DriverJsonTypeTraits.H`:</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;~~~{.c}</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;     NEM_JSON_N_GETTER_SETTER_NAME_TRAITS_BASE(</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;        NEM::DRV::NemDriver,</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;        (... // other drivers</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;            NEM::DRV::FooDriver),</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;        1,</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;        (getProgramType, , NEM::DRV::JSON::programType, JSONCONS_RDONLY,</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;            NEM_JSON_CHECK_KEY_ONLY))</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;    ...</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    #include &quot;Drivers/FooJson.H&quot;</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;~~~</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;Only `DriverJsonTypeTraits.H` should be included in any other source file (and not in any public header). Note that the &lt;em&gt;NEMoSys&lt;/em&gt; drivers &lt;em&gt;JSON&lt;/em&gt; serializations have some standardized names and members. The classes that directly inherit from `NEM::DRV::NemDriver` should have a read-only string-valued key called &quot;Program Type&quot; in the &lt;em&gt;JSON&lt;/em&gt; serialization. Note the pure virtual function `getProgramType` in `NEM::DRV::NemDriver` to enforce this. These classes should (1) have a `static constexpr const char *` member called `programType`, (2) implement `getProgramType` by returning `programType`, and (3) check that the &quot;Program Type&quot; in the &lt;em&gt;JSON&lt;/em&gt; serialization matches `programType`. To make sure that the serialized name is the same across all drivers, note that `DriverJsonTypeTraits.H` defines the `static constexpr NEM::DRV::JSON::programType` so we can avoid typos in repeating the string &quot;Program Type&quot;. Use the `NEM::DRV::JSON` namespace for repeated serialized names!</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;@subsection jsonconsmacros JSONCONS_ macros</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;The macros that have the prefix `JSONCONS` come directly from the &lt;em&gt;jsoncons&lt;/em&gt;library and are well documented [here](https://github.com/danielaparker/jsoncons/blob/v0.159.0/doc/ref/json_type_traits/convenience-macros.md). The most important parts are the table describing the naming conventions and the table describing the parameters of the macros.</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;@subsection nemjsonmacros NEM_JSON_ macros</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;The following additional macros are defined in `NemJsonMacros.H`:</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;~~~{.c}</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;    NEM_JSON_N_MEMBER_NAME_TRAITS_BASE(class_name,</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;        (child_class, child_class, ...),</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;        num_mandatory,</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;        (member0,serialized_name0[,mode0,match0,into0,from0]),</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;        (member1,serialized_name1[,mode1,match1,into1,from1])...)</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;        </div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;    NEM_JSON_N_MEMBER_NAME_TRAITS_INTERMEDIATE(class_name,</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;        (child_class, child_class, ...),</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;        parent_class,</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;        num_mandatory,</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;        (member0,serialized_name0[,mode0,match0,into0,from0]),</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;        (member1,serialized_name1[,mode1,match1,into1,from1])...)</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;        </div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    NEM_JSON_N_MEMBER_NAME_TRAITS_FINAL(class_name,</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;        parent_class,</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;        num_mandatory,</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;        (member0,serialized_name0[,mode0,match0,into0,from0]),</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;        (member1,serialized_name1[,mode1,match1,into1,from1])...)</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;        </div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;    NEM_JSON_N_GETTER_SETTER_NAME_TRAITS_BASE(class_name,</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;        (child_class, child_class, ...),</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;        num_mandatory,</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;        (getter0,setter0,serialized_name0[,mode0,match0,into0,from0]),</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;        (getter1,setter1,serialized_name1[,mode1,match1,into1,from1])...)</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;        </div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;    NEM_JSON_N_GETTER_SETTER_NAME_TRAITS_INTERMEDIATE(class_name,</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;        (child_class, child_class, ...),</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;        parent_class,</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;        num_mandatory,</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;        (getter0,setter0,serialized_name0[,mode0,match0,into0,from0]),</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;        (getter1,setter1,serialized_name1[,mode1,match1,into1,from1])...)</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;        </div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;    NEM_JSON_N_GETTER_SETTER_NAME_TRAITS_FINAL(class_name,</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;        parent_class,</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;        num_mandatory,</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;        (getter0,setter0,serialized_name0[,mode0,match0,into0,from0]),</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;        (getter1,setter1,serialized_name1[,mode1,match1,into1,from1])...)</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;~~~</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;These macros provide more support for polymorphic classes. They operate the same way (and follow the same naming convention) as the `JSONCONS_` macros with the following additions:</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;@subsubsection ptrs Pointers</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;The macros above actually provide partial specializations for `jsoncons::json_type_traits&lt;Json, class_name *&gt;` as opposed to `jsoncons::json_type_traits&lt;Json, class_name&gt;`. Thus, `jsoncons::json_type_traits&lt;Json, class_name *&gt;::as` results in a dynamically allocated object for which the caller takes ownership. Note that `DriverJsonTypeTraits.H` already defines the `jsoncons::json_type_traits&lt;std::unique_ptr&lt;NEM::DRV::NemDriver&gt;&gt;` and `jsoncons::json_type_traits&lt;std::shared_ptr&lt;NEM::DRV::NemDriver&gt;&gt;` specializations.  </div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;@subsubsection polymorphism Polymorphism</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;`BASE`, `INTERMEDIATE`, and `FINAL` represent where a class is in a class hierarchy:</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;- `BASE` refers to classes with no base classes (more precisely, no base classes with members that need to be serialized/deserialized) but with some derived classes.</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;- `INTERMEDIATE` refers to classes with both base and derived classes.</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;- `FINAL` refers to classes that have no derived classes but some base class (that is, effectively `final`).</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;Deserialization for types that use these macros will first use `jsoncons::json_type_traits&lt;&gt;::is` to determine the most derived class (the macros use the `num_mandatory`, `serialized_name`, and `match` parameters to construct the `is` methods), then deserialize the members defined in the macro of the most-derived class, then proceed back up the class hierarchy to deserialize remaining members. In particular, this means that, when using these macros, members that are already listed in a base class&#39;s macros do not need to be repeated in the derived class (unless they need to be treated differently--see the paragraph on `modeN` extensions).</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;@subsubsection typevalcheck Checking Type and Value</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;The `JSONCONS_` macros can check for the presence of mandatory serialized names of a member based on the `num_mandatory` parameter alone. Keep in mind that mandatory names must come first, followed by optional names. They can also check that the corresponding value is valid using the `matchN` parameter. However, there are two pitfalls. First, even if the key would not be checked based on the ordering of the data member and the `num_mandatory` parameter, it &lt;em&gt;is&lt;/em&gt; checked if `matchN` is present, so there is no way to define `matchN` for an optional data member. Second, suppose all we want to verify is that some data member is an array of strings as opposed to a single string. Using `matchN` would require actually creating the data object, whereas a call to `jsoncons::json_type_traits&lt;std::array&lt;std::string&gt;&gt;::is` would be sufficient and cheaper.</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;To resolve these issues, the `NEM_JSON_` macros have slightly different behavior. First, the value of a data member is checked only if the serialized name is present. Second, if the `modeN` parameter is present and the `matchN` parameter is not, then the `jsoncons::json_type_traits&lt;Json, class_name&gt;::is` will call `jsoncons::json_type_traits&lt;Json, member_type&gt;::is` to check the value. If you need to specify `modeN`, `matchN`, `intoN`, or `fromN` but do not want to check the value of the member in `jsoncons::json_type_traits&lt;Json, class_name *&gt;::is}`, use the </div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;`NEM_JSON_CHECK_KEY_ONLY` macro as the `matchN` parameter.</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;@subsection othermacros Other NEM_JSON_ macros</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;There are a few more, less commonly used, macros defined in `NemJsonMacros.H`:</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;~~~{.c}</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;NEM_JSON_WRAP_SMART_PTR(class_name, pointer_template)</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;NEM_JSON_SMART_PTR_VAL(class_name, pointer_template)</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;NEM_JSON_N_MEMBER_NAME_TRAITS_VAL(class_name,num_mandatory,</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;    (member0,serialized_name0[,mode0,match0,into0,from0]),</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;    (member1,serialized_name1[,mode1,match1,into1,from1])...)</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;~~~</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;`NEM_JSON_WRAP_SMART_PTR` defines `jsoncons::json_type_traits&lt;Json, pointer_template&lt;class_name&gt;&gt;` using</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;the template specialization `jsoncons::json_type_traits&lt;Json, class_name *&gt;` (which are what the main `NEM_JSON_` macros above define).  </div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;`NEM_JSON_SMART_PTR_VAL` defines `jsoncons::json_type_traits&lt;Json, pointer_template&lt;class_name&gt;&gt;` using the template specialization</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;`jsoncons::json_type_traits&lt;Json, class_name&gt;`. Note that the specializations for *non-polymorphic* types are [already provided](https://github.com/danielaparker/jsoncons/blob/v0.159.0/doc/ref/json_type_traits/built-in-specializations.md)  </div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;`NEM_JSON_N_MEMBER_NAME_TRAITS_VAL` works exactly as `JSONCONS_N_MEMBER_NAME_TRAITS`, except it additionally supports the `modeN` extensions described above. If you are invoking this template, however, that probably means the class interface needs to be redesigned!</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;@section pythonbindings Python Bindings for Drivers</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;The Python bindings for &lt;em&gt;NEMoSys&lt;/em&gt; are defined in `python/pyNemosys.i` and are constructed using &lt;em&gt;SWIG&lt;/em&gt; (specifically, &lt;em&gt;SWIG&lt;/em&gt; 3.0.12). The `python/CMakeLists.txt` configures a `setup.py` using `setup.py.in`. The `python/CMakeLists.txt` then builds `pyNemosys` by invoking `python setup.py build_ext build`. For details on the `build_ext` command, see the source [here](https://github.com/pypa/setuptools/blob/main/setuptools/command/build_ext.py) which relies on [this](https://github.com/pypa/setuptools/blob/main/setuptools/_distutils/command/build_ext.py). &lt;em&gt;SWIG&lt;/em&gt; generates two files: `pyNemosys_wrap.cpp`, the source for a Python extension module named `_pyNemosys`, and `pyNemosys.py`, a Python module that defines proxy Python classes for &lt;em&gt;NEMoSys&lt;/em&gt; classes using methods defined in `_pyNemosys`. For details on &lt;em&gt;SWIG&lt;/em&gt;, see the [documentation](http://www.swig.org/Doc3.0/SWIGDocumentation.html). Note that there are a few features that are not covered in the documentation; in particular, [this file](https://github.com/swig/swig/blob/v3.0.12/Lib/python/pyuserdir.swg) contains a</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;few undocumented &lt;em&gt;SWIG&lt;/em&gt; directives. The following additions to `pyNemosys.i` show how `FooDriver` might be wrapped:</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;~~~{.c}</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;#include &lt;Drivers/FooDriver.H&gt;</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;%}</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;%include &lt;Drivers/FooDriver.H&gt;</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;EXPOSE_FLATNESTED_PY_CLASSES(FooDriver, Opts)</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;%pythoncode {</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;FooDriver.Files = DriverInOutFiles</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;};</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;CUSTOM_PROPERTIES_INNER_NS(NEM::DRV, FooDriver, Opts, member1)</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;~~~</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;@subsection include include</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;Note the two `include`s above serve two different purposes. The first `include` instructs &lt;em&gt;SWIG&lt;/em&gt; to make sure that `pyNemosys_wrap.cpp` includes `Drivers/FooDriver.H` (the purpose of the `%{ %}` block is to include code verbatim in `pyNemosys_wrap.cpp`). The second `include` is a preprocessor directive for the current file. Thus, after &lt;em&gt;SWIG&lt;/em&gt; preprocesses `pyNemosys.i`, it will wrap any  classes, functions, and global variables in the preprocessed file, including `FooDriver`.</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;@subsection namesandnests Namespaces and Nested Classes</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;By default, &lt;em&gt;SWIG&lt;/em&gt; will ignore namespaces when choosing the Python name for classes, so `NEM::DRV::FooDriver` becomes `FooDriver` (note, however, that the Python classes all live inside the `pyNemosys` module). Because the `flatnested` feature is turned on, &lt;em&gt;SWIG&lt;/em&gt; will wrap nested classes, but not as attributes of the enclosing class. By default, nested classes will be</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;attributes of the `pyNemosys` module. However, this causes collision of type names. `pyNemosys.i` renames these types by prepending an</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;underscore, the enclosing type name, and another underscore. Note the leading underscore, following the Python convention, to suggest internal use.</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;Thus, `NEM::DRV::FooDriver::Opts` will be wrapped as `_FooDriver_Opts`. Finally, using the `EXPOSE_FLATNESTED_PY_CLASSES` macro, we add the wrapped class as an attribute of the outer class with the expected name so that `_FooDriver_Opts` can be accessed as `FooDriver.Opts` in Python.</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;@subsection typealiases Type Aliases</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;&lt;em&gt;SWIG&lt;/em&gt; correctly parses type aliases when generating wrappers, but does not provide the analogous Python attributes. Thus we must manually add attributes using the `%pythoncode` directive, which copies code into `pyNemosys.py`.</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;@subsection stlcontainertypes STL Container Types</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;See [this section](http://www.swig.org/Doc3.0/SWIGDocumentation.html#Library_stl_cpp_library) of the &lt;em&gt;SWIG&lt;/em&gt; documentation on how to wrap STL container types. Note that for types without public default constructors, you must manually ignore constructors that take a size and resize methods.</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;@subsection containersasdata Containers as Data Members</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;By default, in order to enforce type checking, &lt;em&gt;SWIG&lt;/em&gt; wraps public data members as Python [property](https://docs.python.org/3/library/functions.html#property) attributes. They can be set like:</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;~~~{.py}</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;obj = pyNemosys.FooDriver.Opts([0, 1])</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;obj.member2 = 0</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;obj.member1 = pyNemosys.VecInt([1, 2])</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;~~~</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;Note how the constructor converts automatically between the Python list and `std::vector&lt;int&gt;`. The default behavior for member setters does not allow this, instead requiring the user to explicitly create a `std::vector` before assigning to the data member. There is a workaround, however: use the `CUSTOM_PROPERTIES_` macros and list all container members. Then, assignments like the following will work:</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;~~~{.py}</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;obj = pyNemosys.FooDriver.Opts([0, 1])</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;obj.member1 = [1, 2]</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;~~~</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;How does this work? The getter and setter methods that &lt;em&gt;SWIG&lt;/em&gt; generates in `pyNemosys_wrap.cpp` for a member of type `T` return and take `T *`.</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;This is appropriate for the getters; however, for setters, &lt;em&gt;SWIG&lt;/em&gt; won’t do automatic conversions from Python types (except the corresponding Python proxy class), just like temporary values can’t bind to lvalue references in C++. Ṫhe workaround is to extend the class with a getter that returns `T &amp;` and a setter that takes `T`, and monkey-patching the data member as a Python `property`.</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;@subsection optionaljsoncons</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;Just like the STL containers, we need to make &lt;em&gt;SWIG&lt;/em&gt; aware of every `jsoncons::optional&lt;&gt;` type that we plan on using. Use the `OPTIONAL_TEMPLATE_IMMUTABLE` macro for types that are immutable in the Python interface, and `OPTIONAL_TEMPLATE` otherwise (`OPTIONAL_TEMPLATE_IMMUTABLE` turns on `naturalvar` for the type, affecting members of that type). Note that the Python `None` object corresponds to not having a value (the default-constructed `jsoncons::optional`).</div></div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="drivers__dev_8md.html">drivers_dev.md</a></li>
    <li class="footer">Generated on Wed Jan 26 2022 16:22:41 for NEMoSys by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
