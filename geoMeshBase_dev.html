<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NEMoSys: geoMeshBase</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="IRTriangles_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NEMoSys
   &#160;<span id="projectnumber">0.63.0</span>
   </div>
   <div id="projectbrief">A modular, extensible resource with robust automated mesh generation, mesh quality analysis, adaptive mesh refinement, and data transfer between arbitrary meshes.</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('geoMeshBase_dev.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">geoMeshBase </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><code>geoMeshBase</code> is an abstract base class representing a mesh and an optional geometry.</p>
<h1><a class="anchor" id="memorymanagement"></a>
Memory Management</h1>
<p><code>geoMeshBase</code> inherits from <code>vtkDataObject</code>, which takes care of reference counting if used properly. Users of a <code>fooGeoMesh</code> class deriving from <code>geoMeshBase</code> should create a new <code>fooGeoMesh</code> instance in one of the following wats:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> doNothing(fooGeoMesh *fgm) {}</div><div class="line"></div><div class="line">vtkNew&lt;fooGeoMesh&gt; fgm1;</div><div class="line">doNothing(fgm1);</div><div class="line"></div><div class="line"><span class="comment">// vtkSmartPointer&lt;fooGeoMesh&gt; fgm2 = fooGeoMesh::New() is a mistake</span></div><div class="line"><span class="comment">// because the New() on the right and the assignment both</span></div><div class="line"><span class="comment">// increment the reference count</span></div><div class="line">vtkSmartPointer&lt;fooGeoMesh&gt; fgm2 = <a class="code" href="namespaceNEM_1_1MSH.html#a6dec3dd9e4a5682417877ae516d7fce8">vtkSmartPointer&lt;fooGeoMesh&gt;::New</a>();</div><div class="line">doNothing(fgm2);</div><div class="line"></div><div class="line"><span class="comment">// Also see vtkSmartPointer&lt;&gt;::TakeReference</span></div><div class="line">vtkSmartPointer&lt;fooGeoMesh&gt; fgm3 =</div><div class="line">    vtkSmartPointer&lt;fooGeoMesh&gt;::Take(<a class="code" href="namespaceNEM_1_1MSH.html#a6dec3dd9e4a5682417877ae516d7fce8">fooGeoMesh::New</a>());</div><div class="line">doNothing(fgm3);</div><div class="line"></div><div class="line">fooGeoMesh *fgm5 = <a class="code" href="namespaceNEM_1_1MSH.html#a6dec3dd9e4a5682417877ae516d7fce8">fooGeoMesh::New</a>();</div><div class="line">doNothing(fgm5);</div><div class="line">fgm5-&gt;Delete();</div></div><!-- fragment --> <dl class="section warning"><dt>Warning</dt><dd>Note that using a raw pointer requires a call to <code>Delete()</code> and not the C++ keyword <code>delete</code> because other objects may still hold references; <code>Delete()</code> calls <code>delete</code> if the reference count reaches 0. <code>vtkSmartPointer&lt;&gt;</code> or <code>vtkNew&lt;&gt;</code> are preferred to avoid manual <code>Delete()</code> calls.</dd></dl>
<p>Note that none of these are on the stack! <em>VTK</em> hides constructors and disables moves and copies.</p>
<h1><a class="anchor" id="geomesh"></a>
GeoMesh</h1>
<p><code>geoMeshBase</code> objects store data inside the <code>GeoMesh</code> type <code>_geoMesh</code> data member. Let's take a look at the <code>GeoMesh</code> struct (note that it is a protected inner class of <code>geoMeshBase</code>). </p><div class="fragment"><div class="line"><span class="keyword">struct </span>GeoMesh {</div><div class="line">    vtkSmartPointer&lt;vtkUnstructuredGrid&gt; <a class="code" href="RocPartCommGenDriver_8C.html#ae1987ccab405402474115b5c67acd514">mesh</a>;</div><div class="line">    std::string geo;</div><div class="line">    std::string link;</div><div class="line">    SideSet sideSet;</div><div class="line">};</div></div><!-- fragment --><p> The four members of <code>GeoMesh</code> are:</p><ul>
<li><code>mesh</code> contains the mesh. It should never be <code>nullptr</code>. If a <code>geoMeshBase</code> object needs to be reset for some reason, set this field with <code>vtkSmartPointer&lt;vtkUnstructuredGrid&gt;<a class="el" href="namespaceNEM_1_1MSH.html#a6dec3dd9e4a5682417877ae516d7fce8" title="Create a new mesh object. ">New()</a></code>.</li>
<li><code>geo</code>, if not empty, is the name of a gmsh model representing the geometry. Remember to call <code>gmsh::model::setCurrent</code> before other <em>Gmsh</em> API calls.</li>
<li><code>link</code>, if it and <code>geo</code> are not empty, is the name of a <code>vtkDataArray</code> in <code>mesh-&gt;GetCellData()</code> that denotes, for every cell in <code>mesh</code>, which physical group of <code>geo</code> it belongs to.</li>
<li><code>sideSet</code> represents the edges (if the mesh is 2D) or faces (if the mesh is 3D) on the boundaries of physical groups. Therefore, every cell in <code>sideSet.sides</code> ("side cell") is the edge/face of some cell in <code>mesh</code> ("original cell"). Note that <code>sideSet.sides-&gt;GetPoints()</code> and <code>mesh-&gt;GetPoints()</code>, if they both exist, should be pointers to the same object, so that point indices remain consistent. The <code>sideSet.sides</code> has one required cell data array (<code>"GeoEnt"</code>), two arrays that are required if the mesh type represents side sets as sides of a cell (as opposed to <em>Gmsh</em> for example, which represents the mesh elements of Physical Surfaces independently form the elements on any Physical Volume) (<code>"OrigCellIDs"</code> and <code>"CellFaceIds"</code>), and an optional cell data array (<code>"TwinIds"</code>):<ul>
<li><code>"GeoEnt"</code>, aka <code>GeoMeshBase::SIDE_SET_GEO_ENT_NAME</code>, is a <code>vtkIntArray</code> which, for each side cell, contains the physical group that it belongs to in <code>geo</code>.</li>
<li><code>"OrigCellIDs"</code> is a <code>vtkIdTypeArray</code> which, for each side cell, contains the index in <code>mesh</code> of the original cell.</li>
<li><code>"CellFaceIds"</code> is a <code>vtkIntArray</code> which, for each side cell, contains the edge/face of the original cell that has the same set of points (ordering not guaranteed, although normals should have the same direction). Note that this follows <em>VTK</em> indexing, so that an edge/face can be recovered from <code>vtkCell::GetEdge</code> and <code>vtkCell::GetFace</code>, respectively.</li>
<li><code>"TwinIds"</code> is a <code>vtkIdTypeArray</code> which, for each side cell, contains the index in <code>sideSet.sides</code> of the twin side across a material interface (same points, opposite normal) or <code>-1</code> if not such twin exists.</li>
</ul>
</li>
</ul>
<p>Use the constructor/getters/setters for these arrays so that the array names are set correctly. Subclasses of <code>geoMeshBase</code> can use other cell/point/field data arrays if necessary.</p>
<h1><a class="anchor" id="implementation"></a>
Implementing a Driver</h1>
<p>Suppose for some mesh type <code>Foo</code>, we want to implement a <code>fooGeoMesh</code> class that holds a <code>Foo</code> mesh. Here's what the header of the class might look like. Be sure to check ~FILL IN SECTION~ for necessary changes outside of the <code>fooGeoMesh</code> class. </p><div class="fragment"><div class="line"><span class="keyword">class </span>fooGeoMesh : <span class="keyword">public</span> geoMeshBase {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        vtkTypeMacro(fooGeoMesh, geoMeshBase)</div><div class="line">        <span class="keyword">static</span> fooGeoMesh *<a class="code" href="namespaceNEM_1_1MSH.html#a6dec3dd9e4a5682417877ae516d7fce8">New</a>();</div><div class="line">        <span class="keyword">static</span> fooGeoMesh *<a class="code" href="namespaceNEM_1_1MSH.html#a705573738d058a081f60d3ba106d3b84">Read</a>(<span class="keyword">const</span> std::string &amp;fileName);</div><div class="line">        <span class="keywordtype">void</span> write(<span class="keyword">const</span> std::string &amp;fileName) <span class="keyword">override</span>;</div><div class="line">        <span class="keywordtype">void</span> report(std::stream &amp;out) <span class="keyword">const override</span>;</div><div class="line">        <span class="keyword">const</span> Foo &amp;getFooMesh() <span class="keyword">const</span>;</div><div class="line">        <span class="keywordtype">void</span> setFooMesh(Foo fooMesh);</div><div class="line">    <span class="keyword">protected</span>:</div><div class="line">        fooGeoMesh();</div><div class="line">        <span class="keyword">explicit</span> fooGeoMesh(Foo fooMesh);</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        <span class="keyword">static</span> GeoMesh Foo2GM(<span class="keyword">const</span> Foo &amp;fooMesh);</div><div class="line">        <span class="keyword">static</span> Foo GM2Foo(<span class="keyword">const</span> GeoMesh &amp;geoMesh);</div><div class="line">        <span class="keywordtype">void</span> resetNative() <span class="keyword">override</span>;</div><div class="line">        Foo fooMesh_{};</div><div class="line">}</div></div><!-- fragment --><p> Note that <code>fooGeoMesh</code> has a <code>Foo</code> type data member. <code>geoMeshBase</code> is not designed to be aware of external changes to the native mesh type, so <code>geoMeshBase</code> subclasses should own (whether as a data member or using an owning pointer) the mesh of the native type.</p>
<p>The next sections discuss the details of the methods in the header (and other necessary changes!) and tips on implementing them, given in order of suggested implementation. Note that while <code>Foo2GM</code> and <code>GM2Foo</code> are technically optional, implementing these methods is highly recommended to make implementation of other methods easier.</p>
<h2><a class="anchor" id="vtktypemacro"></a>
vtkTypeMacro</h2>
<p>The <code>vtkTypeMacro</code> declares and defines methods that <em>VTK</em> uses to do run-time type checking and cloning. The macro generates both declarations and definitions.</p>
<h2><a class="anchor" id="new"></a>
New</h2>
<p>The static <code>New</code> method is used to create new instances and is also how <code>vtkSmartPointer&lt;&gt;</code> and <code>vtkNew&lt;&gt;</code> create new instances. Sample implementation: </p><div class="fragment"><div class="line"><a class="code" href="namespaceNEM_1_1MSH.html#a057a98ce70ab73b5b44eb2c5ab37670d">vtkStandardNewMacro</a>(fooGeoMesh)</div></div><!-- fragment --> <h2><a class="anchor" id="foo2gm"></a>
Foo2GM</h2>
<p><code>Foo2GM</code> should construct a <code>GeoMesh</code> struct that contains the information in <code>fooMesh_</code>. Its purpose is to simplify the implementation of the <code>fooGeoMesh</code> (<code>FooMesh</code>) constructor (because it should call the <code>geoMeshBase</code> (<code>GeoMesh</code>) constructor in the member initializer list, which can't declare any variables). Recall that the <code>GeoMesh</code> struct has four members (see <a class="el" href="geoMeshBase_dev.html#geomesh">GeoMesh</a> ). If <code>fooMesh_</code> is empty of invalid, set the <code>mesh</code> member to be empty (using <code>vtkSmartPointer&lt;vtkUnstructuredGrid&gt;<a class="el" href="namespaceNEM_1_1MSH.html#a6dec3dd9e4a5682417877ae516d7fce8" title="Create a new mesh object. ">New()</a></code>) as opposed to <code>nullptr</code>. Only set information if it is readily available in <code>fooMesh_</code>! If a <code>Foo</code> has no concept of a geometry, leave <code>geo</code> and <code>link</code> as empty strings. If finding the boundary sides is expensive, use the default-constructed <code>sideSet</code>. Sample implementation: </p><div class="fragment"><div class="line"><span class="keyword">static</span> geoMeshBase::GeoMesh fooGeoMesh::Foo2GM(<span class="keyword">const</span> Foo &amp;fooMesh) {</div><div class="line">    <span class="keyword">auto</span> vug = <a class="code" href="namespaceNEM_1_1MSH.html#a6dec3dd9e4a5682417877ae516d7fce8">vtkSmartPointer&lt;vtkUnstructuredGrid&gt;::New</a>();</div><div class="line">    std::string geo{};</div><div class="line">    std::string link{};</div><div class="line">    SideSet sideSet{};</div><div class="line">    vug-&gt;SetPoints(...);</div><div class="line">    vug-&gt;InsertNextCell(...);</div><div class="line">    <span class="keywordflow">if</span> (fooMesh.hasGeometry()) {</div><div class="line">        GmshInterface::Initialize();</div><div class="line">        std::string geo{<span class="stringliteral">&quot;geoMesh_&quot;</span> + <a class="code" href="namespacenemAux.html#a395d7b5bda246e0da2c1cf1c47e2fb8c">nemAux::getRandomString</a>(6)};</div><div class="line">        gmsh::model::add(geo);</div><div class="line">        gmsh::model::setCurrent(geo);</div><div class="line">        std::string link = GEO_ENT_DEFAULT_NAME;</div><div class="line">        gmsh::model::mesh::addPhysicalGroup(...);</div><div class="line">        <span class="keyword">auto</span> linkArr = <a class="code" href="namespaceNEM_1_1MSH.html#a6dec3dd9e4a5682417877ae516d7fce8">vtkSmartPointer&lt;vtkIntArray&gt;::New</a>();</div><div class="line">        linkArr-&gt;SetName(link.c_str());</div><div class="line">        linkArr-&gt;InsertNextValue(...);</div><div class="line">        vug-&gt;GetCellData()-&gt;AddArray(linkArr);</div><div class="line">        <span class="keyword">auto</span> sideSetPD = <a class="code" href="namespaceNEM_1_1MSH.html#a6dec3dd9e4a5682417877ae516d7fce8">vtkSmartPointer&lt;vtkPolyData&gt;::New</a>();</div><div class="line">        sideSetPD-&gt;SetPoints(vug-&gt;GetPoints());</div><div class="line">        sideSetPD-&gt;InsertNextCell(...);</div><div class="line">        vtkNew&lt;vtkIntArray&gt; sideSetEntArr;</div><div class="line">        sideSet = {sideSetPD, sideSetEntArr};</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> {vug, geo, link, sideSet};</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="gm2foo"></a>
GM2Foo</h2>
<p><code>GM2Foo</code> should construct a <code>Foo</code> object from a <code>GeoMesh</code> struct. Its purpose is to simplify the implementation of <code>resetNative</code>. In particular, using a separate static method reduces the chances of coding mistakes by preventing access to the old <code>fooMesh_</code> that should be overwritten in <code>resetNative</code>. Note that you should alter the signature as necessary in the case that <code>Foo</code> meshes are better represented by more than one object.</p>
<h2><a class="anchor" id="constructors"></a>
Constructors</h2>
<p>The default constructor is necessary for <code>New</code>. It should initialize <code>fooMesh_</code> and <code>GeoMesh</code> to be empty meshes (if using owning pointers to represent the native mesh type, valid objects should be preferred over <code>nullptr</code> to represent empty meshes). The easiest way to do this is to delegate to the <code>fooGeoMesh(Foo)</code> constructor, which itself should use a member initializer list to call the <code>geoMeshBase(GeoMesh)</code> constructor, for example: </p><div class="fragment"><div class="line">fooGeoMesh::fooGeoMesh() : fooGeoMesh(Foo{}) {}</div><div class="line">fooGeoMesh::fooGeoMesh(Foo fooMesh)</div><div class="line">: geoMeshBase(Foo2GM(fooMesh)), fooMesh_(<a class="code" href="namespacestd.html">std</a>::move(fooMesh)) {}</div></div><!-- fragment --><h2><a class="anchor" id="resetnative"></a>
resetNative</h2>
<p>This method should overwrite all <code>Foo</code>-specific data members of <code>fooGeoMesh</code> by using the <code>GM2Foo</code> method on <code>getGeoMesh</code>. Note that this may require calling <code>geoMeshBase::findSide2OrigCell</code> if <code>Foo</code> requires the original cell/face for elements in the <code>geoMeshBase::sideSet</code>. The <code>resetNative</code> method is used by <code>takeGeoMesh</code>, the canonical way of converting between <code>geoMeshBase</code> types, so <code>Foo</code>-specific data members should be treated as stale. Sample implementation: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> fooGeoMesh::resetNative() {</div><div class="line">    fooMesh_ = GM2Foo(getGeoMesh());</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="getfoomesh"></a>
getFooMesh</h2>
<p>This should return a view/read-only version of <code>fooMesh_</code>. Ideally the return type should be <code>const Foo &amp;</code>. If this is not possible, return a copy of <code>fooMesh_</code>. Again, this is because <code>geoMeshBase</code> is not aware of external changes to <code>fooMesh_</code>. Sample implementation: </p><div class="fragment"><div class="line"><span class="keyword">const</span> FooMesh &amp;fooGeoMesh::getFooMesh() {</div><div class="line">    <span class="keywordflow">return</span> fooMesh_;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="setfoomesh"></a>
setFooMesh</h2>
<p>This should reset the object to a state similar to constructing a new object using the <code>fooGeoMesh(Foo)</code> constructor. Sample implementation: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> fooGeoMesh::setFooMesh(Foo fooMesh) {</div><div class="line">    this-&gt;setGeoMesh(Foo2GM(fooMesh));</div><div class="line">    this-&gt;fooMesh_ = std::move(fooMesh);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="read"></a>
Read</h2>
<p>The static <code>Read</code> method should take a file path, read the <code>Foo</code> mesh from the file, and then construct and return a new <code>fooGeoMesh</code>. Sample implementation: </p><div class="fragment"><div class="line">fooGeoMesh *<a class="code" href="namespaceNEM_1_1MSH.html#a705573738d058a081f60d3ba106d3b84">fooGeoMesh::Read</a>(<span class="keyword">const</span> std::string &amp;fileName) {</div><div class="line">    Foo fooMesh{};</div><div class="line">    fooMesh.readFromFile(fileName);</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> fooGeoMesh(std::move(fooMesh));</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="write"></a>
write</h2>
<p>Write the <code>fooMesh_</code> to a file. <code>fooGeoMesh</code> should support the file types that <code>Foo</code> supports. Avoid accessing the <code>GeoMesh</code>; prefer accessing <code>Foo</code>-specific data only.</p>
<h2><a class="anchor" id="report"></a>
report</h2>
<p>Write a short summary of the mesh to a stream. Feel free to make use of <code>geoMeshBase::report</code>. Sample implementation: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> fooGeoMesh::report(std::ostream &amp;out)<span class="keyword"> const </span>{</div><div class="line">    geoMeshBase::report(out);</div><div class="line">    out &lt;&lt; fooMesh_.summary() &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="others"></a>
Other changes</h2>
<p>Be sure to:</p><ul>
<li>Add an enumerator to <code>MeshType</code> that corresponds to <code>fooGeoMesh</code>.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">enum class</span> MeshType {</div><div class="line">    ...,</div><div class="line">    FOO_GEO_MESH</div><div class="line">}</div></div><!-- fragment --><ul>
<li>Add a new case in <code>MeshTypeFromFilename</code> for file extensions that are associated with <code>Foo</code> objects.</li>
</ul>
<div class="fragment"><div class="line">    MeshType <a class="code" href="namespaceNEM_1_1MSH.html#a21938d292e97a88c3109ec65db81573d">MeshTypeFromFilename</a>(<span class="keyword">const</span> std::string &amp;fileName) {</div><div class="line">    std::string fileExt = <a class="code" href="namespacenemAux.html#a1cf6d28d1fb53cc0d2ebc1f98637bbe8">nemAux::find_ext</a>(fileName);</div><div class="line">    ...</div><div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fileExt == <span class="stringliteral">&quot;.foo&quot;</span>) {</div><div class="line">        <span class="keywordflow">return</span> MeshType::FOO_GEO_MESH;</div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">    ...</div><div class="line">}</div></div><!-- fragment --><ul>
<li>Add cases to <code>Read</code> and <code>New</code> for the new <code>MeshType</code> enumerator.</li>
</ul>
<div class="fragment"><div class="line">geoMeshBase *<a class="code" href="namespaceNEM_1_1MSH.html#a705573738d058a081f60d3ba106d3b84">Read</a>(<span class="keyword">const</span> std::string &amp;fileName, MeshType meshType) {</div><div class="line">    <span class="keywordflow">switch</span> (meshType) {</div><div class="line">        ...</div><div class="line">        <span class="keywordflow">case</span> MeshType::FOO_GEO_MESH: <span class="keywordflow">return</span> <a class="code" href="namespaceNEM_1_1MSH.html#a705573738d058a081f60d3ba106d3b84">fooGeoMesh::Read</a>(fileName);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line">geoMeshBase *<a class="code" href="namespaceNEM_1_1MSH.html#a6dec3dd9e4a5682417877ae516d7fce8">New</a>(MeshType meshType) {</div><div class="line">    <span class="keywordflow">switch</span> (meshType) {</div><div class="line">        ...</div><div class="line">        <span class="keywordflow">case</span> MeshType::FOO_GEO_MESH: <span class="keywordflow">return</span> <a class="code" href="namespaceNEM_1_1MSH.html#a6dec3dd9e4a5682417877ae516d7fce8">fooGeoMesh::New</a>();</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><ul>
<li>Add a case for <code>fooGeoMesh</code> in <code>srvBase::RequestDataObject</code>.</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> srvBase::RequestDataObject(vtkInformation *request,</div><div class="line">    vtkInformationVector **inputVector,</div><div class="line">    vtkInformationVector *outputVector) {</div><div class="line">    ...</div><div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (typeName == <span class="stringliteral">&quot;fooGeoMesh&quot;</span>) {</div><div class="line">        output = <a class="code" href="namespaceNEM_1_1MSH.html#a6dec3dd9e4a5682417877ae516d7fce8">MSH::fooGeoMesh::New</a>();</div><div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (typeName == <span class="stringliteral">&quot;geoMeshBase&quot;</span>) {</div><div class="line">        ...</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Jan 26 2022 16:40:03 for NEMoSys by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
