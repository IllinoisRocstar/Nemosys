<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NEMoSys: srvBase_dev.md Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="IRTriangles_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NEMoSys
   &#160;<span id="projectnumber">0.63.0</span>
   </div>
   <div id="projectbrief">A modular, extensible resource with robust automated mesh generation, mesh quality analysis, adaptive mesh refinement, and data transfer between arbitrary meshes.</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('srvBase__dev_8md.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">srvBase_dev.md</div>  </div>
</div><!--header-->
<div class="contents">
<a href="srvBase__dev_8md.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;@page srvBase_dev srvBase</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;`srvBase` is an abstract base class that implements complex operations on `geoMeshBase` objects. Note that `srvBase` inherits from `vtkAlgorithm`, so the memory management tips in @ref geomeshbase also apply to `srvBase` objects. Some additional resources for understanding `vtkAlgorithm`:</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;- This [wiki page](https://vtk.org/Wiki/VTK/Tutorials/New_Pipeline) provides an overview of `vtkAlgorithm`.</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;- The [VTK Users&#39; Guide](https://www.kitware.com/products/books/VTKUsersGuide.pdf) chapters 15 and 17 offer a more detailed guide to implementing custom `vtkAlgorithm`s. (Caution: this book was written for VTK 5.4!)</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;- The new [VTK examples site](https://kitware.github.io/vtk-examples/site/) includes an updated overview (see VTKBook &gt; Chapter 4, in particular sections 4.2-4.4) and full \cpp\ examples (see Cxx &gt; Developers).</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;- This [series of blog posts](https://blog.kitware.com/a-vtk-pipeline-primer-part-1/) provides examples (mostly Python) of a custom `vtkAlgorithm` as well as some explanation of the design of `vtkAlgorithm`.</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;@section execution Execution</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;Note that `srvBase` objects can be pipelined, that is, services can take the other `srvBase` objects as inputs. More precisely, output ports and input ports of different `srvBase` objects can be connected, as in:</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;~~~{.c}</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    vtkNew&lt;fooGeoMesh&gt; mesh;</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    vtkNew&lt;myFooSrv&gt; srv1;</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;    vtkNew&lt;myFooSrv&gt; srv2;</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    srv1-&gt;SetInputDataObject(mesh);</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    srv2-&gt;SetInputConnection(srv1-&gt;GetOutputPort());</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    srv2-&gt;Update();</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;~~~</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;Execution of the entire pipeline only happens when `Update` is called on `srv2`. If the service has not been modified since the last time it was updated, then it does nothing. Otherwise, the service and any inputs to the service that need to be updated (and their inputs and so on) do four things, in the following order:</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;- `RequestDataObject` is called on each service in the forward direction, meaning `RequestDataObject` is called on a service&#39;s inputs before it is called on the service (`srv1` before `srv2`). This method creates empty objects to store the results of a service.</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;- `RequestInformation` is called on each service in the forward direction. This method passes metadata about the result of a service to subsequent services that might need it.</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;- `RequestUpdateExtent` is called on each service in the backward direction, meaning `RequestDataObject` is called on a service before it is called on the service&#39;s inputs (`srv2` before `srv1`). This method tells its input services what portion of the data it needs, in case the input service can save resources by only partially executing.</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;- `RequestData` is called on each service in the forward direction. `RequestData` runs the actual algorithm that a service represents by writing data into the object previously created by `RequestDataObject`.</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;Note that the input and output information and data are all passed between services via `vtkInformation`, which holds key-value pairs, where the keys are instances of `vtkInformationKey`.</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;@section implementation Implementing a srvBase class</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;Suppose we want to implement some service `myFooSrv` that takes `fooGeoMesh` objects, runs some algorithm, and results in another `fooGeoMesh` object, with some option `Bar` that controls the algorithm. Here&#39;s what the header of `myFooSrv` might look like:</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;~~~{.c}</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    class myFooSrv : public srvBase {</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;        public:</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;            vtkTypeMacro(myFooSrv, srvBase)</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;            static myFooSrv *New();</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;            vtkSetMacro(Bar, int);</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;            vtkGetMacro(Bar, int);</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;        protected:</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;            myFooSrv();</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;            int RequestData(vtkInformation *request,</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;                vtkInformationVector **inputVector,</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;                vtkInformationVector *outputVector) override;</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;            int FillInputPortInformation(int port, vtkInformation *info) override;</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;            int FillOutputPortInformation(int port, vtkInformation *info) override;</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;        private:</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;            int Bar{};</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    }</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;~~~</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;Note the use of Pascal/upper camel case for the private data member `Bar` so that the setters and getters created by `vtkSetMacro` and `vtkGetMacro` are consistently capitalized.</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;@subsection vtktypemacro vtkTypeMacro</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;The `vtkTypeMacro` declares and defines methods that &lt;em&gt;VTK&lt;/em&gt; uses to do run-time type checking and cloning. The macro generates both declarations and definitions.</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;@subsection new New</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;The static `New` method is used to create new instances, and is also how `vtkSmartPointer&lt;&gt;` and `vtkNew&lt;&gt;` create new instances.</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;Sample implementation:</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;~~~{.c}</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    vtkStandardNewMacro(myFooSrv)</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;~~~</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;@subsection setandget vtkSetMacro and vtkGetMacro</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;Prefer using these macros (and similar ones in `vtkSetGet.h`) for implementing setters and getters of options of services. In particular, if writing custom setter functions (or any functions that alter the execution of the algorithm), remember to call `Modified` before returning.</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;@subsection portinfo FillInputPortInformation and FillOutputPortInformation</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;The inputs and outputs of a service (generally `geoMeshBase` objects; simpler inputs can be treated as options) are defined in terms of ports. Input ports should at least set the `INPUT_REQUIRED_DATA_TYPE()` key so that the input data type can be checked. Other keys that might be of interest include `vtkAlgorithm::INPUT_IS_OPTIONAL()` and `vtkAlgorithm::INPUT_IS_REPEATABLE()`. Output ports should at least set the `DATA_TYPE_NAME()` key so that the output data type can be checked and so that the appropriate data type is used in `RequestDataObject`. Note that the value for `DATA_TYPE_NAME()` should be the same for all instances of the service. If you find yourself tempted to set this value depending on options or the input, you most likely need to override `RequestDataObject` and implement the logic there. The return values indicate success (`1`) or failure (`0`).</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;Sample implementation:</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;~~~{.c}</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;    int myFooSrv::FillInputPortInformation(int port, vtkInformation *info) {</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;        if (port == 0) {</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;            info-&gt;Set(vtkAlgorithm::INPUT_REQUIRED_DATA_TYPE(), &quot;fooGeoMesh&quot;);</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;            return 1;</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;        }</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;        return 0;</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;    }</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;    int myFooSrv::FillOutputPortInformation(int port, vtkInformation *info) {</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;        if (port == 0) {</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;            info-&gt;Set(vtkDataObject::DATA_TYPE_NAME(), &quot;fooGeoMesh&quot;);</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;            return 1;</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;        }</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;        return 0;</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    }</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;~~~</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;@subsection constructor Constructor</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;The constructor should set the number of input and output ports for the service.</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;Sample implementation:</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;~~~{.c}</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    myFooSrv::myFooSrv() {</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;        this-&gt;SetNumberOfInputPorts(1);</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;        this-&gt;SetNumberOfOutputPorts(1);</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;    }</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;~~~</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;@subsection requestdata RequestData</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;This method contains the main logic of the service. Note that the input and output objects are contained in the `inputVector` and `outputVector` arguments. Be sure to return `0` on failure or `1` on success.</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;Sample implementation:</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;~~~{.c}</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    int myFooSrv::RequestData(vtkInformation *request,</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;        vtkInformationVector **inputVector,</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;        vtkInformationVector *outputVector) {</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;        // first index corresponds to input port</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;        // second index used if input is repeatable</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;        auto inInfo = inputVector[0]-&gt;GetInformationObject(0);</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;        // index corresponds to output port</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;        auto outInfo = outputVector-&gt;GetInformationObject(0);</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;        auto input = MSH::fooGeoMesh::SafeDownCast(</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;            inInfo-&gt;Get(vtkDataObject::DATA_OBJECT()));</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;        auto output = MSH::fooGeoMesh::SafeDownCast(</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;            outInfo-&gt;Get(vtkDataObject::DATA_OBJECT()));</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;        Foo outputFoo = input-&gt;getFooMesh(); // copy</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;        outputFoo.runAlgorithm(this-&gt;Bar);</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;        output-&gt;setFooMesh(std::move(outputFoo));</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;        return 1;</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    }</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;~~~</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;@subsection requestdataobject RequestDataObject</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;This method creates the output data object for the service before anything is executed. `srvBase` contains a default implementation for this method, which uses the `vtkDataObject::DATA_TYPE_NAME()` key. If the value given by this key refers to a concrete type, then a new instance of the concrete type will be created. If the value associated with `DATA_TYPE_NAME()` is `&quot;geoMeshBase&quot;`, then the output object will be created by calling `NewInstance` on the input object of the input port (specifically, the first object on the input port with the same index). If some custom logic is needed for creating the output object, override this method. Ths overridden method should create the output data object and set it as the value for the `vtkDataObject::DATA_OBJECT()` key for each `vtkInformation` in the `outputVector`. Be sure to return `0` on failure or `1` on success Note that each `FillOutputPortInformation` should set the `DATA_TYPE_NAME()` key even in `RequestDataObject` is overridden.</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;@subsection requestinfo RequestInformation</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;This method provides metadata about the output that subsequent services might need. The `srvBase` implementation does nothing; override it if needed.</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;@subsection requestupdateextent RequestUpdateExtent</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;This method notifies input services about what extent of the input it needs. The `srvBase` implementation sets `vtkStreamingDemandDrivenPipeline::EXACT_EXTENT()` to 1 for all inputs. Override it if needed, particularly for streaming algorithms.</div></div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="srvBase__dev_8md.html">srvBase_dev.md</a></li>
    <li class="footer">Generated on Wed Jan 26 2022 16:40:02 for NEMoSys by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
