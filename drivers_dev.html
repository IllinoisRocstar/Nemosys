<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NEMoSys: $title</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="IRTriangles_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NEMoSys
   &#160;<span id="projectnumber">0.63.0</span>
   </div>
   <div id="projectbrief">A modular, extensible resource with robust automated mesh generation, mesh quality analysis, adaptive mesh refinement, and data transfer between arbitrary meshes.</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('drivers_dev.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="contents">
<div class="textblock"><p>The driver classes (which inherit from <code>NEM::MSH::NemDriver</code>) are the highest level of abstraction. Each driver represents some workflow that can be executed using the virtual <code>NemDriver::execute()</code> method. Users specify parameters via getters and setters. Note that the drivers also can be run from the command line using the <code>nemosysRun</code> executable and a <em>JSON</em> file, or in Python via <code>pyNemosys</code>.</p>
<h1><a class="anchor" id="implementation"></a>
Implementing a Driver</h1>
<p>Suppose we want to implement some driver <code>FooDriver</code>. Here's what the header of <code>FooDriver</code> might look like:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>NEMOSYS_EXPORT FooDriver : <span class="keyword">public</span> NemDriver {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="keyword">using</span> Files = DriverInOutFiles;</div><div class="line"></div><div class="line">        <span class="keyword">struct </span>NEMOSYS_EXPORT Opts {</div><div class="line">            <span class="keyword">public</span>:</div><div class="line">                <span class="keyword">explicit</span> Opts(std::vector&lt;int&gt; member1);</div><div class="line">                std::vector&lt;int&gt; member1;</div><div class="line">                <span class="keywordtype">double</span> member2{0.9};</div><div class="line">                jsoncons::optional&lt;int&gt; member3{};</div><div class="line">                JSONCONS_TYPE_TRAITS_FRIEND</div><div class="line">            <span class="keyword">private</span>:</div><div class="line">                Opts() = <span class="keywordflow">default</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        FooDriver(Files files, Opts opts);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> Files &amp;getFiles() <span class="keyword">const</span>;</div><div class="line">        <span class="keywordtype">void</span> setFiles(Files files);</div><div class="line">        <span class="keyword">const</span> Opts &amp;getOpts() <span class="keyword">const</span>;</div><div class="line">        <span class="keywordtype">void</span> setOpts(Opts opts);</div><div class="line">        <span class="keywordtype">void</span> execute() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">        JSONCONS_TYPE_TRAITS_FRIEND</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        FooDriver();</div><div class="line">        <span class="keyword">static</span> constexpr <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="namespaceNEM_1_1DRV_1_1JSON.html#adde45f0b2ca9da567f0dcd352acfaad4">programType</a> = <span class="stringliteral">&quot;Foo&quot;</span>;</div><div class="line">        jsoncons::string_view getProgramType() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">        Files files_;</div><div class="line">        Opts opts_;</div><div class="line">}</div></div><!-- fragment --><p>Ideally, drivers only do two things: accept parameters for some workflow, and execute it. To that end, note that <code>execute</code> is <code>const</code>, because there should be no reason to alter the state of the driver when running. The following sections describe some of the members in more detail.</p>
<h2><a class="anchor" id="privateconstructors"></a>
Private Constructors</h2>
<p>The way that <em>NEMoSys</em> implements <em>JSON</em> deserialization requires that classes have default constructors. However, if the class would not otherwise have a default constructor (because some members need to be set by the user in order for the object to be meaningful), make the default constructor private and use the <code>JSONCONS_TYPE_TRAITS_FRIEND</code> macro so that the <em>JSON</em> deserialization can use the default constructor. If the default constructor requires an explicit definition, set the required values to any value&ndash;the <em>JSON</em> interface will ensure at run-time that the user provides a value. See <a class="el" href="drivers_dev.html#deserialization">JSON Deserialization for Drivers</a> for details on <em>JSON</em> deserialization.</p>
<h2><a class="anchor" id="filesopts"></a>
Files, files_, Opts, and opts_</h2>
<p>Drivers act on files and a set of parameters. To group these, most drivers have nested classes (with standardized names <code>Files</code> and <code>Opts</code>) and one member of each of these types (note the trailing underscore for private members, following the Google C++ style guide). The <code>struct</code> keyword rather than <code>class</code> is used to suggest that the purpose of these nested classes is just to hold data. Note that many drivers have just a single output mesh file, or have an input and an output. Use an alias declaration, if necessary (with the <code>using</code> keyword) to enforce consistent naming.</p>
<p>Drivers have both required and optional parameters. To enforce this, make sure any publicly available constructors have some way to set each required parameter, so that all <code>Opts</code> structs are always in a valid state. Member variables with default values should be initialized where they are declared, rather than through the constructor, both so that it is obvious from the header alone what the default value is, and so that the default constructor can be defined using <code>= default</code>. Note that in some cases, options can be turned on or off, but turning them on requires additional parameters. To represent these types of optional values, use the <code>jsoncons::optional&lt;T&gt;</code> template, which represents an object of type <code>T</code> or the absence of any object at all. For more info about <code>jsoncons::optional</code>, note that is has the same interface as <code>std::optional</code>.</p>
<h2><a class="anchor" id="deserialization"></a>
JSON Deserialization for Drivers</h2>
<p>Deserialization of a type from <em>JSON</em> relies on macros that generate code defining a specialization of the <code>jsoncons::json_type_traits&lt;Json, T&gt;</code> template. Please read https://github.com/danielaparker/jsoncons/blob/v0.159.0/doc/ref/json_type_traits.md "this page" from the <em>jsoncons</em> documentation. Note that in addition to the macros documented {<a href="https://github.com/danielaparker/jsoncons/blob/v0.159.0/doc/ref/json_type_traits/convenience-macros.md">https://github.com/danielaparker/jsoncons/blob/v0.159.0/doc/ref/json_type_traits/convenience-macros.md</a> "here", <em>NEMoSys</em> provides additional macros to support virtual inheritance in <code><a class="el" href="NemJsonMacros_8H.html">NemJsonMacros.H</a></code>. Specializations for many STL types (including more containers, <code>std::pair</code>, <code>std::optional</code>, <code>std::shared_ptr</code>, <code>std::unique_ptr</code>, and <code>jsoncons::optional</code>) are https://github.com/danielaparker/jsoncons/blob/v0.159.0/doc/ref/json_type_traits/built-in-specializations.md "already provided" based on specializations of <code>jsoncons::json_type_traits&lt;Json,T&gt;</code> for the templated type. The following is an example of using these macros for <code>FooDriver</code>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef NEMOSYS_FOOJSON_H_</span></div><div class="line"><span class="preprocessor">#define NEMOSYS_FOOJSON_H_</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;Drivers/FooDriver.H&quot;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="NemJsonMacros_8H.html">Drivers/NemJsonMacros.H</a>&quot;</span></div><div class="line"></div><div class="line"><a class="code" href="NemJsonMacros_8H.html#ae668dc5838c15279c78c12bfe67ca21b">NEM_JSON_N_GETTER_SETTER_NAME_TRAITS_FINAL</a>(</div><div class="line">    NEM::DRV::FooDriver, <a class="code" href="classNEM_1_1DRV_1_1NemDriver.html">NEM::DRV::NemDriver</a>, 2,</div><div class="line">    (getFiles, setFiles, <a class="code" href="namespaceNEM_1_1DRV_1_1JSON.html#ab5d4c08ee92a39928bf3cb5ab83258e0">NEM::DRV::JSON::meshFiles</a>),</div><div class="line">    (getOpts, setOpts, <span class="stringliteral">&quot;Foo Driver Options&quot;</span>),</div><div class="line">    (getProgramType, , <a class="code" href="namespaceNEM_1_1DRV_1_1JSON.html#adde45f0b2ca9da567f0dcd352acfaad4">NEM::DRV::JSON::programType</a>, <a class="code" href="NemJsonMacros_8H.html#a7306320b0f32ce5dbc0dcebf7eb37761">NEM_JSON_RDONLY_OVERRIDE</a>,</div><div class="line">        [](<span class="keyword">const</span> jsoncons::string_view &amp;x) {</div><div class="line">            <span class="keywordflow">return</span> x == <a class="code" href="namespaceNEM_1_1DRV_1_1JSON.html#adde45f0b2ca9da567f0dcd352acfaad4">NEM::DRV::FooDriver::programType</a>;</div><div class="line">        }))</div><div class="line"></div><div class="line">JSONCONS_N_MEMBER_NAME_TRAITS(<a class="code" href="namespaceNEM.html">NEM</a>::DRV::FooDriver::Opts, 1,</div><div class="line">    (member1, &quot;First Option&quot;),</div><div class="line">    (member2, &quot;Second Option&quot;),</div><div class="line">    (member3, &quot;Third Option&quot;))</div><div class="line"></div><div class="line"><span class="preprocessor">#endif // NEMOSYS_FOOJSON_H_</span></div></div><!-- fragment --><p>This file might be named <code>FooJson.H</code> and live under <code>include/Drivers</code> (possibly within a subdirectory, mimicking where <code>FooJson.C</code> is located). Note that <code>FooJson.H</code> should not be installed! Finally, make sure to add <code>FooDriver</code> to <code><a class="el" href="DriverJsonTypeTraits_8H.html">DriverJsonTypeTraits.H</a></code>:</p>
<div class="fragment"><div class="line"> <a class="code" href="NemJsonMacros_8H.html#a40accd321c76d0f90d6e4822e607540d">NEM_JSON_N_GETTER_SETTER_NAME_TRAITS_BASE</a>(</div><div class="line">    <a class="code" href="classNEM_1_1DRV_1_1NemDriver.html">NEM::DRV::NemDriver</a>,</div><div class="line">    (... <span class="comment">// other drivers</span></div><div class="line">        NEM::DRV::FooDriver),</div><div class="line">    1,</div><div class="line">    (getProgramType, , <a class="code" href="namespaceNEM_1_1DRV_1_1JSON.html#adde45f0b2ca9da567f0dcd352acfaad4">NEM::DRV::JSON::programType</a>, JSONCONS_RDONLY,</div><div class="line">        <a class="code" href="NemJsonMacros_8H.html#abd31b124c21eedbd4a0dac5caf718a56">NEM_JSON_CHECK_KEY_ONLY</a>))</div><div class="line">...</div><div class="line">#include <span class="stringliteral">&quot;Drivers/FooJson.H&quot;</span></div></div><!-- fragment --><p>Only <code><a class="el" href="DriverJsonTypeTraits_8H.html">DriverJsonTypeTraits.H</a></code> should be included in any other source file (and not in any public header). Note that the <em>NEMoSys</em> drivers <em>JSON</em> serializations have some standardized names and members. The classes that directly inherit from <code><a class="el" href="classNEM_1_1DRV_1_1NemDriver.html" title="base class for drivers ">NEM::DRV::NemDriver</a></code> should have a read-only string-valued key called "Program Type" in the <em>JSON</em> serialization. Note the pure virtual function <code>getProgramType</code> in <code><a class="el" href="classNEM_1_1DRV_1_1NemDriver.html" title="base class for drivers ">NEM::DRV::NemDriver</a></code> to enforce this. These classes should (1) have a <code>static constexpr const char *</code> member called <code>programType</code>, (2) implement <code>getProgramType</code> by returning <code>programType</code>, and (3) check that the "Program Type" in the <em>JSON</em> serialization matches <code>programType</code>. To make sure that the serialized name is the same across all drivers, note that <code><a class="el" href="DriverJsonTypeTraits_8H.html">DriverJsonTypeTraits.H</a></code> defines the <code>static constexpr <a class="el" href="namespaceNEM_1_1DRV_1_1JSON.html#adde45f0b2ca9da567f0dcd352acfaad4">NEM::DRV::JSON::programType</a></code> so we can avoid typos in repeating the string "Program Type". Use the <code><a class="el" href="namespaceNEM_1_1DRV_1_1JSON.html">NEM::DRV::JSON</a></code> namespace for repeated serialized names!</p>
<h2><a class="anchor" id="jsonconsmacros"></a>
JSONCONS_ macros</h2>
<p>The macros that have the prefix <code>JSONCONS</code> come directly from the <em>jsoncons</em>library and are well documented https://github.com/danielaparker/jsoncons/blob/v0.159.0/doc/ref/json_type_traits/convenience-macros.md "here". The most important parts are the table describing the naming conventions and the table describing the parameters of the macros.</p>
<h2><a class="anchor" id="nemjsonmacros"></a>
NEM_JSON_ macros</h2>
<p>The following additional macros are defined in <code><a class="el" href="NemJsonMacros_8H.html">NemJsonMacros.H</a></code>:</p>
<div class="fragment"><div class="line"><a class="code" href="NemJsonMacros_8H.html#a441aad4ce817fd63ceb6ed71c7f2d648">NEM_JSON_N_MEMBER_NAME_TRAITS_BASE</a>(class_name,</div><div class="line">    (child_class, child_class, ...),</div><div class="line">    num_mandatory,</div><div class="line">    (member0,serialized_name0[,mode0,match0,into0,from0]),</div><div class="line">    (member1,serialized_name1[,mode1,match1,into1,from1])...)</div><div class="line"></div><div class="line"><a class="code" href="NemJsonMacros_8H.html#a93c8ecf1396f15754eab755460e0205f">NEM_JSON_N_MEMBER_NAME_TRAITS_INTERMEDIATE</a>(class_name,</div><div class="line">    (child_class, child_class, ...),</div><div class="line">    parent_class,</div><div class="line">    num_mandatory,</div><div class="line">    (member0,serialized_name0[,mode0,match0,into0,from0]),</div><div class="line">    (member1,serialized_name1[,mode1,match1,into1,from1])...)</div><div class="line"></div><div class="line"><a class="code" href="NemJsonMacros_8H.html#a92c161d670eda64906bee3e00e06e895">NEM_JSON_N_MEMBER_NAME_TRAITS_FINAL</a>(class_name,</div><div class="line">    parent_class,</div><div class="line">    num_mandatory,</div><div class="line">    (member0,serialized_name0[,mode0,match0,into0,from0]),</div><div class="line">    (member1,serialized_name1[,mode1,match1,into1,from1])...)</div><div class="line"></div><div class="line"><a class="code" href="NemJsonMacros_8H.html#a40accd321c76d0f90d6e4822e607540d">NEM_JSON_N_GETTER_SETTER_NAME_TRAITS_BASE</a>(class_name,</div><div class="line">    (child_class, child_class, ...),</div><div class="line">    num_mandatory,</div><div class="line">    (getter0,setter0,serialized_name0[,mode0,match0,into0,from0]),</div><div class="line">    (getter1,setter1,serialized_name1[,mode1,match1,into1,from1])...)</div><div class="line"></div><div class="line"><a class="code" href="NemJsonMacros_8H.html#a178e192f98a01e65b4b518547d7ffbff">NEM_JSON_N_GETTER_SETTER_NAME_TRAITS_INTERMEDIATE</a>(class_name,</div><div class="line">    (child_class, child_class, ...),</div><div class="line">    parent_class,</div><div class="line">    num_mandatory,</div><div class="line">    (getter0,setter0,serialized_name0[,mode0,match0,into0,from0]),</div><div class="line">    (getter1,setter1,serialized_name1[,mode1,match1,into1,from1])...)</div><div class="line"></div><div class="line"><a class="code" href="NemJsonMacros_8H.html#ae668dc5838c15279c78c12bfe67ca21b">NEM_JSON_N_GETTER_SETTER_NAME_TRAITS_FINAL</a>(class_name,</div><div class="line">    parent_class,</div><div class="line">    num_mandatory,</div><div class="line">    (getter0,setter0,serialized_name0[,mode0,match0,into0,from0]),</div><div class="line">    (getter1,setter1,serialized_name1[,mode1,match1,into1,from1])...)</div></div><!-- fragment --><p>These macros provide more support for polymorphic classes. They operate the same way (and follow the same naming convention) as the <code>JSONCONS_</code> macros with the following additions:</p>
<h3><a class="anchor" id="ptrs"></a>
Pointers</h3>
<p>The macros above actually provide partial specializations for <code>jsoncons::json_type_traits&lt;Json, class_name *&gt;</code> as opposed to <code>jsoncons::json_type_traits&lt;Json, class_name&gt;</code>. Thus, <code>jsoncons::json_type_traits&lt;Json, class_name *&gt;::as</code> results in a dynamically allocated object for which the caller takes ownership. Note that <code><a class="el" href="DriverJsonTypeTraits_8H.html">DriverJsonTypeTraits.H</a></code> already defines the <code>jsoncons::json_type_traits&lt;std::unique_ptr&lt;<a class="el" href="classNEM_1_1DRV_1_1NemDriver.html" title="base class for drivers ">NEM::DRV::NemDriver</a>&gt;&gt;</code> and <code>jsoncons::json_type_traits&lt;std::shared_ptr&lt;<a class="el" href="classNEM_1_1DRV_1_1NemDriver.html" title="base class for drivers ">NEM::DRV::NemDriver</a>&gt;&gt;</code> specializations.</p>
<h3><a class="anchor" id="polymorphism"></a>
Polymorphism</h3>
<p><code>BASE</code>, <code>INTERMEDIATE</code>, and <code>FINAL</code> represent where a class is in a class hierarchy:</p><ul>
<li><code>BASE</code> refers to classes with no base classes (more precisely, no base classes with members that need to be serialized/deserialized) but with some derived classes.</li>
<li><code>INTERMEDIATE</code> refers to classes with both base and derived classes.</li>
<li><code>FINAL</code> refers to classes that have no derived classes but some base class (that is, effectively <code>final</code>).</li>
</ul>
<p>Deserialization for types that use these macros will first use <code>jsoncons::json_type_traits&lt;&gt;::is</code> to determine the most derived class (the macros use the <code>num_mandatory</code>, <code>serialized_name</code>, and <code>match</code> parameters to construct the <code>is</code> methods), then deserialize the members defined in the macro of the most-derived class, then proceed back up the class hierarchy to deserialize remaining members. In particular, this means that, when using these macros, members that are already listed in a base class's macros do not need to be repeated in the derived class (unless they need to be treated differently&ndash;see the paragraph on <code>modeN</code> extensions).</p>
<h3><a class="anchor" id="typevalcheck"></a>
Checking Type and Value</h3>
<p>The <code>JSONCONS_</code> macros can check for the presence of mandatory serialized names of a member based on the <code>num_mandatory</code> parameter alone. Keep in mind that mandatory names must come first, followed by optional names. They can also check that the corresponding value is valid using the <code>matchN</code> parameter. However, there are two pitfalls. First, even if the key would not be checked based on the ordering of the data member and the <code>num_mandatory</code> parameter, it <em>is</em> checked if <code>matchN</code> is present, so there is no way to define <code>matchN</code> for an optional data member. Second, suppose all we want to verify is that some data member is an array of strings as opposed to a single string. Using <code>matchN</code> would require actually creating the data object, whereas a call to <code>jsoncons::json_type_traits&lt;std::array&lt;std::string&gt;&gt;::is</code> would be sufficient and cheaper. To resolve these issues, the <code>NEM_JSON_</code> macros have slightly different behavior. First, the value of a data member is checked only if the serialized name is present. Second, if the <code>modeN</code> parameter is present and the <code>matchN</code> parameter is not, then the <code>jsoncons::json_type_traits&lt;Json, class_name&gt;::is</code> will call <code>jsoncons::json_type_traits&lt;Json, member_type&gt;::is</code> to check the value. If you need to specify <code>modeN</code>, <code>matchN</code>, <code>intoN</code>, or <code>fromN</code> but do not want to check the value of the member in <code>jsoncons::json_type_traits&lt;Json, class_name *&gt;::is}</code>, use the <code>NEM_JSON_CHECK_KEY_ONLY</code> macro as the <code>matchN</code> parameter.</p>
<h2><a class="anchor" id="othermacros"></a>
Other NEM_JSON_ macros</h2>
<p>There are a few more, less commonly used, macros defined in <code><a class="el" href="NemJsonMacros_8H.html">NemJsonMacros.H</a></code>:</p>
<div class="fragment"><div class="line"><a class="code" href="NemJsonMacros_8H.html#a38b245394ee2cca0f93405bb235a186e">NEM_JSON_WRAP_SMART_PTR</a>(class_name, pointer_template)</div><div class="line"><a class="code" href="NemJsonMacros_8H.html#a7cb72bc55a31ca451f31f05b768d9ccd">NEM_JSON_SMART_PTR_VAL</a>(class_name, pointer_template)</div><div class="line"><a class="code" href="NemJsonMacros_8H.html#abe10477fa2b4143d937087e171be659b">NEM_JSON_N_MEMBER_NAME_TRAITS_VAL</a>(class_name,num_mandatory,</div><div class="line">    (member0,serialized_name0[,mode0,match0,into0,from0]),</div><div class="line">    (member1,serialized_name1[,mode1,match1,into1,from1])...)</div></div><!-- fragment --><p><code>NEM_JSON_WRAP_SMART_PTR</code> defines <code>jsoncons::json_type_traits&lt;Json, pointer_template&lt;class_name&gt;&gt;</code> using the template specialization <code>jsoncons::json_type_traits&lt;Json, class_name *&gt;</code> (which are what the main <code>NEM_JSON_</code> macros above define). <code>NEM_JSON_SMART_PTR_VAL</code> defines <code>jsoncons::json_type_traits&lt;Json, pointer_template&lt;class_name&gt;&gt;</code> using the template specialization <code>jsoncons::json_type_traits&lt;Json, class_name&gt;</code>. Note that the specializations for <em>non-polymorphic</em> types are https://github.com/danielaparker/jsoncons/blob/v0.159.0/doc/ref/json_type_traits/built-in-specializations.md "already provided" <code>NEM_JSON_N_MEMBER_NAME_TRAITS_VAL</code> works exactly as <code>JSONCONS_N_MEMBER_NAME_TRAITS</code>, except it additionally supports the <code>modeN</code> extensions described above. If you are invoking this template, however, that probably means the class interface needs to be redesigned!</p>
<h1><a class="anchor" id="pythonbindings"></a>
Python Bindings for Drivers</h1>
<p>The Python bindings for <em>NEMoSys</em> are defined in <code>python/pyNemosys.i</code> and are constructed using <em>SWIG</em> (specifically, <em>SWIG</em> 3.0.12). The <code>python/CMakeLists.txt</code> configures a <code>setup.py</code> using <code>setup.py.in</code>. The <code>python/CMakeLists.txt</code> then builds <code>pyNemosys</code> by invoking <code>python setup.py build_ext build</code>. For details on the <code>build_ext</code> command, see the source <a href="https://github.com/pypa/setuptools/blob/main/setuptools/command/build_ext.py">here</a> which relies on <a href="https://github.com/pypa/setuptools/blob/main/setuptools/_distutils/command/build_ext.py">this</a>. <em>SWIG</em> generates two files: <code>pyNemosys_wrap.cpp</code>, the source for a Python extension module named <code>_pyNemosys</code>, and <code>pyNemosys.py</code>, a Python module that defines proxy Python classes for <em>NEMoSys</em> classes using methods defined in <code>_pyNemosys</code>. For details on <em>SWIG</em>, see the <a href="http://www.swig.org/Doc3.0/SWIGDocumentation.html">documentation</a>. Note that there are a few features that are not covered in the documentation; in particular, <a href="https://github.com/swig/swig/blob/v3.0.12/Lib/python/pyuserdir.swg">this file</a> contains a few undocumented <em>SWIG</em> directives. The following additions to <code>pyNemosys.i</code> show how <code>FooDriver</code> might be wrapped:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Drivers/FooDriver.H&gt;</span></div><div class="line">%}</div><div class="line">%include &lt;Drivers/FooDriver.H&gt;</div><div class="line">EXPOSE_FLATNESTED_PY_CLASSES(FooDriver, Opts)</div><div class="line">%pythoncode {</div><div class="line">FooDriver.Files = DriverInOutFiles</div><div class="line">};</div><div class="line">CUSTOM_PROPERTIES_INNER_NS(<a class="code" href="namespaceNEM_1_1DRV.html">NEM::DRV</a>, FooDriver, Opts, member1)</div></div><!-- fragment --><h2><a class="anchor" id="include"></a>
include</h2>
<p>Note the two <code>include</code>s above serve two different purposes. The first <code>include</code> instructs <em>SWIG</em> to make sure that <code>pyNemosys_wrap.cpp</code> includes <code>Drivers/FooDriver.H</code> (the purpose of the <code>%{ %}</code> block is to include code verbatim in <code>pyNemosys_wrap.cpp</code>). The second <code>include</code> is a preprocessor directive for the current file. Thus, after <em>SWIG</em> preprocesses <code>pyNemosys.i</code>, it will wrap any classes, functions, and global variables in the preprocessed file, including <code>FooDriver</code>.</p>
<h2><a class="anchor" id="namesandnests"></a>
Namespaces and Nested Classes</h2>
<p>By default, <em>SWIG</em> will ignore namespaces when choosing the Python name for classes, so <code>NEM::DRV::FooDriver</code> becomes <code>FooDriver</code> (note, however, that the Python classes all live inside the <code>pyNemosys</code> module). Because the <code>flatnested</code> feature is turned on, <em>SWIG</em> will wrap nested classes, but not as attributes of the enclosing class. By default, nested classes will be attributes of the <code>pyNemosys</code> module. However, this causes collision of type names. <code>pyNemosys.i</code> renames these types by prepending an underscore, the enclosing type name, and another underscore. Note the leading underscore, following the Python convention, to suggest internal use. Thus, <code>NEM::DRV::FooDriver::Opts</code> will be wrapped as <code>_FooDriver_Opts</code>. Finally, using the <code>EXPOSE_FLATNESTED_PY_CLASSES</code> macro, we add the wrapped class as an attribute of the outer class with the expected name so that <code>_FooDriver_Opts</code> can be accessed as <code>FooDriver.Opts</code> in Python.</p>
<h2><a class="anchor" id="typealiases"></a>
Type Aliases</h2>
<p><em>SWIG</em> correctly parses type aliases when generating wrappers, but does not provide the analogous Python attributes. Thus we must manually add attributes using the <code>pythoncode</code> directive, which copies code into <code>pyNemosys.py</code>.</p>
<h2><a class="anchor" id="stlcontainertypes"></a>
STL Container Types</h2>
<p>See <a href="http://www.swig.org/Doc3.0/SWIGDocumentation.html#Library_stl_cpp_library">this section</a> of the <em>SWIG</em> documentation on how to wrap STL container types. Note that for types without public default constructors, you must manually ignore constructors that take a size and resize methods.</p>
<h2><a class="anchor" id="containersasdata"></a>
Containers as Data Members</h2>
<p>By default, in order to enforce type checking, <em>SWIG</em> wraps public data members as Python <a href="https://docs.python.org/3/library/functions.html#property">property</a> attributes. They can be set like:</p>
<div class="fragment"><div class="line">obj = pyNemosys.FooDriver.Opts([0, 1])</div><div class="line">obj.member2 = 0</div><div class="line">obj.member1 = pyNemosys.VecInt([1, 2])</div></div><!-- fragment --><p>Note how the constructor converts automatically between the Python list and <code>std::vector&lt;int&gt;</code>. The default behavior for member setters does not allow this, instead requiring the user to explicitly create a <code>std::vector</code> before assigning to the data member. There is a workaround, however: use the <code>CUSTOM_PROPERTIES_</code> macros and list all container members. Then, assignments like the following will work:</p>
<div class="fragment"><div class="line">obj = pyNemosys.FooDriver.Opts([0, 1])</div><div class="line">obj.member1 = [1, 2]</div></div><!-- fragment --><p>How does this work? The getter and setter methods that <em>SWIG</em> generates in <code>pyNemosys_wrap.cpp</code> for a member of type <code>T</code> return and take <code>T *</code>. This is appropriate for the getters; however, for setters, <em>SWIG</em> won’t do automatic conversions from Python types (except the corresponding Python proxy class), just like temporary values can’t bind to lvalue references in C++. Ṫhe workaround is to extend the class with a getter that returns <code>T &amp;</code> and a setter that takes <code>T</code>, and monkey-patching the data member as a Python <code>property</code>.</p>
<h2><a class="anchor" id="optionaljsoncons"></a>
optionaljsoncons</h2>
<p>Just like the STL containers, we need to make <em>SWIG</em> aware of every <code>jsoncons::optional&lt;&gt;</code> type that we plan on using. Use the <code>OPTIONAL_TEMPLATE_IMMUTABLE</code> macro for types that are immutable in the Python interface, and <code>OPTIONAL_TEMPLATE</code> otherwise (<code>OPTIONAL_TEMPLATE_IMMUTABLE</code> turns on <code>naturalvar</code> for the type, affecting members of that type). Note that the Python <code>None</code> object corresponds to not having a value (the default-constructed <code>jsoncons::optional</code>). </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Jan 26 2022 16:40:03 for NEMoSys by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
