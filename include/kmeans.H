// C++ implementation of K-Means clustering for n-dimensional data.
//
// This class follows the standard Expectation-Maximization iterative algorithm,
// also known by Lloyd's algorithm:
//   Repeat until convergence:
//      - Assign all points to the nearest cluster.
//      - Compute the cluster mean based on its assigned points.
//   Convergence is when the cluster assignment doesn't change.
//   The initialization of the means uses k random points from the data.
//
// Adopted from Felix Duvallet

#ifndef __KMEANS_KMEANS_H__
#define __KMEANS_KMEANS_H__

#include "nemosys_export.h"

#include <map>
#include <string>
#include <vector>
#include "point.H"


using namespace NEM::GEO;

namespace NEM {

namespace MTH {
/**
  @brief Basic KMeans algorithm implementation
**/
class NEMOSYS_EXPORT KMeans 
{
  public:
  /**
    @brief constructor
    @param K is the number of clusters we want. 
    @param max_terations Max iterations is just to prevent running forever.
  **/
  KMeans(int k, int max_iterations = 100);

  /**
    @brief Copy all the given points.
    @param points array of point object used for initialization
  **/
  bool init(const std::vector<Point> &points);

  /**
     @brief Run the algorithm until convergence.
  **/
  bool run();

  /**
    @brief Load the points from file and into the vector. 
    File should be tab separated without header and other
    comments.
    @param filepath is the full path to the file
    @param points is vector point objects
  **/
  static bool loadPoints(const std::string &filepath,
                         std::vector<Point> *points);

  /** 
    @breif Sets verbosity to true
  **/
  void verbose() {_vrb=true;}

  public:
  /**
    @breif prints the computes mean point coordinates
  **/
  void printMeans();

  /** 
    @brief Write means to file, in the same format as the input file.
    @param filepath is the full path to the file
   **/
  void writeMeans(const std::string &filepath);

  /**
    @breif returns vector of points
    @return the vector of points provided as input
  **/
  const std::vector<Point> &getPoints() const 
  {
    return points_;
  }

  /**
    @breif returns means as a vector of points
    @return the vector of points representing means
  **/
  const std::vector<Point> &getMeans() const 
  {
    return means_;
  }

  protected:
  // Assign each point to the nearest cluster. Returns true if any point's
  // cluster assignment has changed, so we can detect convergence.
  bool assign();

  // Compute the means to be the average of all the points in each cluster.
  bool update_means();
  
  // Returns the index of the cluster nearest to this point.
  int findNearestCluster(const Point &point);
  
  // Computes a new cluster mean (output parameter mean) using the points in
  // that cluster. The multimap is mapping from cluster_id -> Point* (it is
  // generated by update_means).
  void computeClusterMean(
    const std::multimap<int, const Point *> &multimap,
    int cluster,
    Point *mean);

  protected:
  // Number of clusters, the means, and all the points stored.
  int num_clusters_;
  int max_iterations_;
  std::vector<Point> means_;
  std::vector<Point> points_;
  bool _vrb;

};

} // namespace MTH

} // namespace NEM

#endif  // __KMEANS_KMEANS_H__
