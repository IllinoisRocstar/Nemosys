#ifndef ORTHOPOLY3D_H
#define ORTHOPOLY3D_H

#include <iostream>
#include <memory>
#include <orthoPoly1D.H>
#ifdef DEBUG
  #include <Timer.H>
#endif
using Eigen::Matrix;
using Eigen::ArrayXd;
using Eigen::KroneckerProduct;
using Eigen::Dynamic;
using Eigen::RowMajor;

//class orthoPoly1D;

// TODO: Generalize to higher order elements with more than one internal node per patch
//       where averages need to be taken for duplicate recovered vaules


// defines dynamicall sized matrix stype with row-major storage
// this is used to optimize computations involving access to entire rows
typedef Matrix<double,Dynamic,Dynamic,RowMajor> MatrixXdRM;


// remove given row from matrix
void removeRow(Eigen::MatrixXd& matrix, unsigned int rowToRemove);

// remove rows from given matrix
void removeRow(const MatrixXdRM& matrix, 
               MatrixXdRM& matrix_red,
               const std::vector<unsigned int>& toRemove);

void removeRow(const MatrixXd& matrix, 
               MatrixXdRM& matrix_red,
               const std::vector<unsigned int>& toRemove);
// remove given column from matrix
void removeColumn(Eigen::MatrixXd& matrix, unsigned int colToRemove);

class orthoPoly3D
{
 
  // constructors and destructors 
  public:
		// default ctor
		orthoPoly3D();
   
		// complete ctor 
    orthoPoly3D(int _order, const VectorXd& _sigma, 
								const std::vector<double>& _x, const std::vector<double>& _y, 
								const std::vector<double>& _z);
		
		// partial ctor, must manually call computeA
		orthoPoly3D(int _order, const std::vector<std::vector<double>>& coords);

		// move constructor
    orthoPoly3D(orthoPoly3D&& op); 

		// move assignment	
    orthoPoly3D& operator=(orthoPoly3D&& op);

 		// dtor
    ~orthoPoly3D(){}

  // methods
  public:
    #ifdef DEBUG
    // compute multivariate polynomial approximation of prescribed order to sigma
    void run1(const VectorXd& sigma);
    #endif
    // compute coefficients for polynomial expansion of sampled function
		void computeA(const VectorXd& sigma);
    // evaluate the fitting polynomial at coord
    const double operator()(const std::vector<double>& coord);
    // return the status of the approximant object
    // 1 indicates approximant is available, 0 otherwise 
		const bool status() const {return finished;}	
    // reset the object to its default state
		void Reset();
    VectorXd getCoeffs() { return a; }
			
  private:
    // total order of basis
    int order;
    // 1D basis generated by x coords
		std::unique_ptr<orthoPoly1D> opx;
    // 1D basis generated by y coords
		std::unique_ptr<orthoPoly1D> opy;
    // 1D basis generated by z coords 
		std::unique_ptr<orthoPoly1D> opz;
    // coefficients of polynomial approximant
    VectorXd a;
    // rows/cols to remove from basis matrices to limit total order
    std::vector<unsigned int> toRemove;
		// status bool
    bool finished;
  // compiler safe guards
  private: 
    // private lvalue copy ctor disables it (not implemented)
		orthoPoly3D(const orthoPoly3D&) = delete;
    // private lvalue copy assignment ctor disables it (not implemented)
    orthoPoly3D& operator=(const orthoPoly3D&) = delete; 
		// checks order compatiblity and determines toRemove array
		void initCheck();
};

#endif
